{"version":3,"file":"PenrosePrograms-e6acd945.js","sources":["../../../examples/dist/linear-algebra-domain/linear-algebra-paper-simple.style.js","../../../examples/dist/linear-algebra-domain/linear-algebra.domain.js","../../../examples/dist/linear-algebra-domain/twoVectorsPerp-unsugared.substance.js","../../../examples/dist/set-theory-domain/continuousmap.style.js","../../../examples/dist/set-theory-domain/continuousmap.substance.js","../../../examples/dist/set-theory-domain/functions.domain.js","../../../examples/dist/set-theory-domain/setTheory.domain.js","../../../examples/dist/set-theory-domain/venn.style.js","../../src/stories/PenrosePrograms.tsx"],"sourcesContent":["import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"linear-algebra-domain\");\nexport default \"canvas {\\n  width = 400\\n  height = 500\\n}\\n\\nconst {\\n  scalar perpLen = 20.0\\n  -- For unit mark\\n  scalar markerPadding = 15.0\\n  scalar barSize = 5.0\\n  scalar vectorSpaceSize = 350.0\\n  scalar repelWeight = 0.7\\n  scalar arrowheadSize = 0.7\\n  scalar lineThickness = 2.\\n  string fontFamily = \\\"Palatino\\\"\\n  string fontSize = \\\"22.5px\\\"\\n}\\n\\nC {\\n  color black = rgba(0.,0.,0.,1.)\\n  color white = rgba(1., 1., 1., 1.)\\n  color lightBlue = rgba(1e-1, 0.1, 0.9, 1.0)\\n  -- Note: we don't currently support color accessors r,g,b\\n  -- darkBlue = rgba(lightBlue.r / 2., lightBlue.g / 2., lightBlue.b / 2., 0.5)\\n  color darkGray = rgba(0.4, 0.4, 0.4, 1.)\\n  color gray = rgba(0.6, 0.6, 0.6, 1.)\\n  color green = rgba(0., 0.8, 0., 1.)\\n  color none = none()\\n}\\n\\nforall VectorSpace U {\\n  scalar axisSize = const.vectorSpaceSize / 2.0 -- This should get promoted to float\\n  vec2 U.origin = (0., 0.)\\n  vec2 o = U.origin\\n  color U.axisColor = C.gray\\n\\n  shape U.background = Rectangle {\\n    center : U.origin\\n    width : const.vectorSpaceSize\\n    height : const.vectorSpaceSize\\n    fillColor : rgba(.95,.95,.95,1.)\\n    strokeColor : C.none\\n  }\\n\\n  shape U.xAxis = Line {\\n    start : (o[0] - 1.1*axisSize, o[1]) -- TODO This gets mis-parsed as a matrix access\\n    end : (o[0] + 1.1*axisSize, o[1])\\n    strokeWidth : const.lineThickness\\n    style : \\\"solid\\\"\\n    strokeColor : U.axisColor\\n\\n  }\\n\\n  shape U.yAxis = Line {\\n    start : (o[0], o[1] - 1.1*axisSize)\\n    end : (o[0], o[1] + 1.1*axisSize)\\n    strokeWidth : const.lineThickness\\n    style : \\\"solid\\\"\\n    strokeColor : U.axisColor\\n  }\\n\\n  shape U.text = Text {\\n    fontSize : const.fontSize\\n    fontFamily : const.fontFamily\\n    fontStyle : \\\"italic\\\"\\n    string : U.label\\n    center : (U.origin[0] + .8*axisSize, U.origin[1] + .8*axisSize)\\n    fillColor : U.axisColor\\n  }\\n\\n  layer U.xAxis above U.yAxis\\n  layer U.background below U.yAxis\\n  layer U.text above U.background\\n  layer U.text below U.yAxis\\n}\\n\\nforall Vector u; VectorSpace U\\nwhere In(u,U) {\\n\\n  shape u.arrow = Line {\\n    start : U.origin\\n    end : (?, ?)\\n    strokeWidth : 3.0\\n    strokeColor : C.lightBlue\\n    endArrowhead: \\\"straight\\\"\\n    endArrowheadSize : const.arrowheadSize\\n  }\\n\\n  shape u.text = Text {\\n    center: u.arrow.end * 1.15\\n    fontSize: const.fontSize\\n    fontFamily: const.fontFamily\\n    fontWeight: \\\"bold\\\"\\n    string: u.label\\n    fillColor: u.arrow.strokeColor\\n  }\\n\\n  shape u.stroke = Text {\\n    center: u.text.center\\n    fontSize: u.text.fontSize\\n    fontFamily: u.text.fontFamily\\n    fontWeight: \\\"bold\\\"\\n    string: u.label\\n    fillColor: C.white\\n    strokeColor: C.white\\n    strokeWidth: 8.\\n  }\\n\\n  vec2 u.vector = u.arrow.end - u.arrow.start -- Vector sugar for subtraction\\n\\n  ensure contains(U.background, u.arrow)\\n  ensure contains(U.background, u.text)\\n  ensure minSize(u.arrow)\\n\\n  layer u.text above u.stroke\\n  layer u.stroke above u.arrow\\n  layer u.arrow above U.xAxis\\n  layer u.text above U.xAxis\\n  layer u.text above U.yAxis\\n  layer u.text above U.xAxis\\n}\\n\\n-- draw all labels above all arrows, to improve legibility\\nforall Vector u; Vector v {\\n  layer u.stroke above v.arrow\\n  layer v.stroke above u.arrow\\n}\\n\\nforall Vector u; Vector v\\nwith VectorSpace U\\nwhere Orthogonal(u, v); In(u, U); In(v, U) {\\n  startR = u.arrow.start\\n  endR = u.arrow.end\\n  startL = v.arrow.start\\n  endL = v.arrow.end\\n  dirR = normalize(endR - startR)  \\n  dirL = normalize(endL - startL)\\n  ptL = startR + const.perpLen * dirL\\n  ptR = startR + const.perpLen * dirR\\n  ptLR = ptL + const.perpLen * dirR\\n  pts = [startR, ptL, ptLR, ptR]\\n\\n  -- Draw perpendicular mark -- NOTE: local shapes should still be drawn\\n  perpMark = Path {\\n    d : pathFromPoints(\\\"closed\\\", pts)\\n    strokeWidth : 2.0\\n    strokeColor : C.black\\n    fillColor : C.white\\n  }\\n\\n  ensure equal(dot(u.vector, v.vector), 0.0) \\n\\n  layer v.arrow above perpMark\\n  layer u.arrow above perpMark\\n  layer perpMark above U.xAxis\\n\\n  shape labelText = Text {\\n    string: \\\"orthogonal\\\"\\n    center: (0.,-.6*U.background.width)\\n    fontFamily: const.fontFamily\\n    fontSize: \\\"18px\\\"\\n    fontWeight: \\\"bold\\\"\\n    fillColor: C.black\\n  }\\n}\\n\\nforall Vector v\\nwith VectorSpace U; Vector w\\nwhere In(v, U); Unit(v); Orthogonal(v, w) {\\n  -- Usually, the unit vector shouldn't need to know about orthogonal vectors\\n  -- but we need to position the unit mark so it doesn't overlap with the \\\"inside\\\" of the two vectors\\n\\n  strokeWidth = 2.0\\n  padding = 15.0 \\n\\n  -- The start and end of the body of the unit marker line\\n  -- NOTE: We need to have lists of vectors\\n  dir = normalize(w.arrow.end - w.arrow.start)\\n  normal = -dir\\n  markStart = v.arrow.start + padding * normal\\n  markEnd = v.arrow.end + padding * normal\\n  v.markerLine = [markStart, markEnd]\\n\\n  v.unitMarkerLine = Path {\\n    d : pathFromPoints(\\\"open\\\", v.markerLine)\\n    strokeColor : C.black\\n    fillColor : C.none\\n  }\\n\\n  -- Could use normal instead, just doing this to demonstrate how to use matrices\\n  mat2x2 rot90CW = ((0., 1.), (-1., 0.))\\n  vec2 markNormal = mul(rot90CW, normalize(v.arrow.end - v.arrow.start)) \\n  scalar c = const.barSize\\n  vec2 halfvec = c * markNormal\\n\\n  v.unitMarkerEnd1 = Path {\\n    d : pathFromPoints(\\\"open\\\", [markStart - halfvec, markStart + halfvec]) \\n    strokeColor : C.black\\n    fillColor : C.none\\n  }\\n\\n  v.unitMarkerEnd2 = Path {\\n    d : pathFromPoints(\\\"open\\\", [markEnd - halfvec, markEnd + halfvec])\\n    strokeColor : C.black\\n    fillColor : C.none\\n  }\\n\\n  vec2 midpointLoc = (v.markerLine[0] + v.markerLine[1]) / 2.\\n  vec2 labelPos = midpointLoc + const.markerPadding * normal\\n\\n  v.unitMarkerText = Equation {\\n    fontSize : const.fontSize\\n    string : \\\"1\\\"\\n    center : labelPos\\n    fillColor : C.black\\n  }\\n\\n  layer v.unitMarkerLine above U.xAxis\\n  layer v.unitMarkerLine above U.yAxis\\n}\\n\\n-- If two vectors are linearly dependent, make\\n-- sure they are parallel by minimizing the\\n-- signed are of the parallelogram with sides u,v\\nforall Vector u; Vector v\\nwhere Dependent(u,v) {\\n  vec2 x = u.arrow.end\\n  vec2 y = v.arrow.end\\n  scalar A = cross2D(x,y)\\n  ensure equal( A, 0. )\\n\\n  shape labelText = Text {\\n    string: \\\"linearly dependent\\\"\\n    center: (0.,-.6*V.background.width)\\n    fontFamily: const.fontFamily\\n    fontSize: \\\"18px\\\"\\n    fontWeight: \\\"bold\\\"\\n    fillColor: C.black\\n  }\\n}\\n\\n-- If two vectors are linearly independent, make\\n-- sure they're not parallel\\nforall Vector u; Vector v; VectorSpace V\\nwhere Independent(u, v); In(v,V) {\\n  vec2 x = u.arrow.end\\n  vec2 y = v.arrow.end\\n  ensure inRange( angleBetween(x,y), .25*MathPI(), .75*MathPI() )\\n\\n  shape labelText = Text {\\n    string: \\\"linearly independent\\\"\\n    center: (0.,-.6*V.background.width)\\n    fontFamily: const.fontFamily\\n    fontSize: \\\"18px\\\"\\n    fontWeight: \\\"bold\\\"\\n    fillColor: C.black\\n  }\\n}\\n\\nforall Vector `u` {\\n  override `u`.arrow.strokeColor = C.green\\n}\\n\\nforall Vector `x2` {\\n  override `x2`.arrow.strokeColor = C.green\\n}\\n\\n\\n\\n\";\n//# sourceMappingURL=linear-algebra-paper-simple.style.js.map","export default \"-- Types\\ntype Scalar\\ntype VectorSpace\\ntype Vector\\ntype LinearMap\\n\\n-- Operators\\nfunction neg(Vector v) -> Vector\\nfunction scale(Scalar c, Vector v) -> Vector cv\\nfunction addV(Vector, Vector) -> Vector\\nfunction addS(Scalar s1, Scalar s2) -> Scalar\\nfunction norm(Vector v) -> Scalar\\nfunction innerProduct(Vector, Vector) -> Scalar\\nfunction determinant(Vector, Vector) -> Scalar\\nfunction apply(LinearMap f, Vector) -> Vector\\n\\n-- Predicates\\npredicate In(Vector, VectorSpace V)\\npredicate From(LinearMap V, VectorSpace domain, VectorSpace codomain)\\npredicate Orthogonal(Vector v1, Vector v2)\\npredicate Independent(Vector v1, Vector v2)\\npredicate Dependent(Vector v1, Vector v2)\\npredicate Unit(Vector v)\\n\\n-- Syntactic sugar\\n-- notation \\\"det(v1, v2)\\\" ~ \\\"determinant(v1, v2)\\\"\\n-- notation \\\"LinearMap f : U → V\\\" ~ \\\"LinearMap f; From(f, U, V)\\\"\\n-- notation \\\"v1 + v2\\\" ~ \\\"addV(v1, v2)\\\"\\n-- notation \\\"-v1\\\" ~ \\\"neg(v1)\\\"\\n-- notation \\\"Vector a ∈ U\\\" ~ \\\"Vector a; In(a, U)\\\"\\n-- notation \\\"|y1|\\\" ~ \\\"norm(y1)\\\"\\n-- notation \\\"<v1,v2>\\\" ~ \\\"innerProduct(v1, v2)\\\"\\n-- notation \\\"s * v1\\\" ~ \\\"scale(s, v1)\\\"\\n-- notation \\\"Scalar c := \\\" ~ \\\"Scalar c; c := \\\"\\n-- notation \\\"f(v)\\\" ~ \\\"apply(f, v)\\\"\\n\\n-- Examples for prelude, just for reproducing (Should be removed)\\n\\n--value T : VectorSpace\\n-- value T1 : VectorSpace\\n\";\n//# sourceMappingURL=linear-algebra.domain.js.map","export default \"VectorSpace V\\nVector u \\nIn(u, V)\\nVector v \\nIn(v, V)\\nUnit(u)\\nOrthogonal(v, u)\\nAutoLabel All\\n\";\n//# sourceMappingURL=twoVectorsPerp-unsugared.substance.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"set-theory-domain\");\nexport default \"canvas {\\n  width = 800\\n  height = 700\\n}\\n\\nConst {\\n  strokeWidth = 1.5\\n  padding = 20.0\\n}\\n\\nColors {\\n  black = #000000\\n  lightBlue = #1a1ae633\\n  lightYellow = setOpacity(#f2f5eb, 0.5)\\n}\\n\\nforall Set x {\\n    x.icon = Circle {\\n        fillColor : Colors.lightBlue\\n        strokeColor : Colors.black\\n        strokeStyle : \\\"solid\\\"\\n        strokeWidth : 1.0\\n        -- rotation : 0.0\\n    }\\n\\n    x.text    = Equation {\\n      string : x.label\\n      -- rotation : 0.0\\n    }\\n\\n    x.labelFn = ensure contains(x.icon, x.text)\\n    x.icon below x.text\\n}\\n\\n-- Selector ordering matters!\\nforall Set x; Set y\\nwhere IsSubset(x, y) {\\n  ensure contains(y.icon, x.icon, 10.0)\\n  -- y.sizeFn    = ensure smallerThan(x.icon, y.icon)\\n  y.outsideFn = ensure disjoint(y.text, x.icon, 1.0)\\n  x.icon above y.icon\\n}\\n\\nforall Map f\\nwhere From(f, X, Y); IsSubset(X, R1); IsSubset(Y, R2)\\nwith Set X; Set Y; Set R1; Set R2 {\\n  f.padding = 20.0\\n\\n    f.icon = Line {\\n      start : (R1.icon.center[0] + R1.icon.width / 2.0 + f.padding, R1.icon.center[1])\\n      end : (R2.icon.center[0] - R2.icon.width / 2.0 - f.padding, R2.icon.center[1])\\n      strokeWidth : 2.0\\n      strokeColor : Colors.black\\n      endArrowhead: \\\"straight\\\"\\n        -- style : \\\"curved\\\"\\n    }\\n\\n    f.text = Equation {\\n      -- Doesn't seem to work after the first resample. Is the server updating f.text.height on resample?\\n      -- x : (f.icon.startX + f.icon.endX) / 2.0\\n      -- y : (f.icon.startY + f.icon.endY) / 2.0 + 1.1 * f.text.height\\n      string : f.label\\n    }\\n\\n    encourage centerLabelAbove(f.icon, f.text, 5.0)\\n}\\n\\nforall Set `U` {\\n    override `U`.icon.strokeStyle = \\\"dashed\\\"\\n    override `U`.icon.strokeWidth = Const.strokeWidth\\n}\\n\\nforall Set `V` {\\n    override `V`.icon.strokeStyle = \\\"dashed\\\"\\n    override `V`.icon.strokeWidth = Const.strokeWidth\\n}\\n\\n-- TODO: use subtyping for reals?\\nforall Set `Rn` {\\n    `Rn`.iconSize = canvas.height / 3\\n\\n    override `Rn`.icon = Rectangle {\\n      -- Works but is slow\\n      -- x : -100.0\\n      -- y = 0.0\\n      width : `Rn`.iconSize\\n      height : `Rn`.iconSize\\n      fillColor : Colors.lightYellow\\n      -- rotation : 0.0\\n      strokeWidth : Const.strokeWidth\\n      strokeColor : Colors.black\\n    }\\n\\n    override `Rn`.text.center = (`Rn`.icon.center[0] + `Rn`.icon.width / 2.0 - Const.padding, `Rn`.icon.center[1] + `Rn`.icon.width / 2.0 - Const.padding)\\n\\n    delete `Rn`.labelFn\\n    delete `Rn`.outsideFn\\n\\n}\\n\\nforall Set `Rm`\\nwith Set `Rn` {\\n    -- TODO: factor this block out\\n    override `Rm`.icon = Rectangle {\\n        fillColor : Colors.lightYellow\\n        center : (`Rn`.icon.center[0] + 400.0, `Rn`.icon.center[1])\\n        width : `Rn`.iconSize\\n        height : `Rn`.iconSize\\n        -- rotation : 0.0\\n        strokeWidth : 1.0\\n        strokeColor : Colors.black\\n    }\\n\\n     override `Rm`.text.center = (`Rm`.icon.center[0] + `Rm`.icon.width / 2.0 - Const.padding, `Rm`.icon.center[1] + `Rm`.icon.width / 2.0 - Const.padding)\\n\\n    delete `Rm`.labelFn\\n    delete `Rm`.outsideFn\\n\\n    -- This doesn't seem to work\\n    --    `Rm`.posFn = encourage topRightOf(`Rm`.text, `Rm`.icon)\\n}\";\n//# sourceMappingURL=continuousmap.style.js.map","export default \"AutoLabel All\\n\\nSet A\\nSet U\\nLabel U $f^{-1}(V)$\\nSet Rn\\nLabel Rn $\\\\mathbb{R}^n$\\nIsSubset(U, A)\\nIsSubset(A, Rn)\\n\\nSet B\\nSet V\\nSet Rm\\nLabel Rm $\\\\mathbb{R}^m$\\nIsSubset(V, B)\\nIsSubset(B, Rm)\\n\\nMap f\\nFrom(f, A, B)\";\n//# sourceMappingURL=continuousmap.substance.js.map","export default \"type Set\\ntype Point\\ntype Map\\n\\nconstructor Singleton(Point p) -> Set\\n\\nfunction Intersection(Set a, Set b) -> Set\\nfunction Union(Set a, Set b) -> Set\\nfunction Subtraction(Set a, Set b) -> Set\\nfunction CartesianProduct(Set a, Set b) -> Set\\nfunction Difference(Set a, Set b) -> Set\\nfunction Subset(Set a, Set b) -> Set\\nfunction AddPoint(Point p, Set s1) -> Set\\n\\npredicate From(Map f, Set domain, Set codomain)\\npredicate Empty(Set s)\\npredicate Intersecting(Set s1, Set s2)\\npredicate IsSubset(Set s1, Set s2)\\npredicate Equal(Set s1, Set s2)\\npredicate PointIn(Set s, Point p)\\npredicate In(Point p, Set s)\\npredicate Injection(Map m)\\npredicate Surjection(Map m)\\npredicate Bijection(Map m)\\npredicate PairIn(Point, Point, Map)\\n\";\n//# sourceMappingURL=functions.domain.js.map","export default \"type Set\\n\\npredicate NotIntersecting(Set s1, Set s2)\\npredicate Intersecting(Set s1, Set s2)\\npredicate IsSubset(Set s1, Set s2)\\n\";\n//# sourceMappingURL=setTheory.domain.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"set-theory-domain\");\nexport default \"canvas {\\n  width = 800\\n  height = 700\\n}\\n\\nforall Set x {\\n  shape x.icon = Circle { }\\n  shape x.text = Equation {\\n    string : x.label\\n    fontSize : \\\"32px\\\"\\n  }\\n  ensure contains(x.icon, x.text)\\n  encourage norm(x.text.center - x.icon.center) == 0\\n  layer x.text above x.icon\\n}\\n\\nforall Set x; Set y\\nwhere IsSubset(x, y) {\\n  ensure disjoint(y.text, x.icon, 10)\\n  ensure contains(y.icon, x.icon, 5)\\n  layer x.icon above y.icon\\n}\\n\\nforall Set x; Set y\\nwhere NotIntersecting(x, y) {\\n  ensure disjoint(x.icon, y.icon)\\n}\\n\\nforall Set x; Set y\\nwhere Intersecting(x, y) {\\n  ensure overlapping(x.icon, y.icon)\\n  ensure disjoint(y.text, x.icon)\\n  ensure disjoint(x.text, y.icon)\\n}\\n\";\n//# sourceMappingURL=venn.style.js.map","import exteriorAlgebraDomain from \"@penrose/examples/dist/exterior-algebra/exterior-algebra.domain\";\nimport exteriorAlgebraStyle from \"@penrose/examples/dist/exterior-algebra/exterior-algebra.style\";\nimport vectorWedgeSubstance from \"@penrose/examples/dist/exterior-algebra/vector-wedge.substance\";\nimport linearAlgebraStyle from \"@penrose/examples/dist/linear-algebra-domain/linear-algebra-paper-simple.style\";\nimport linearAlgebraDomain from \"@penrose/examples/dist/linear-algebra-domain/linear-algebra.domain\";\nimport twoVectorsPerpSubstance from \"@penrose/examples/dist/linear-algebra-domain/twoVectorsPerp-unsugared.substance\";\nimport continuousMapStyle from \"@penrose/examples/dist/set-theory-domain/continuousmap.style\";\nimport continuousMapSubstance from \"@penrose/examples/dist/set-theory-domain/continuousmap.substance\";\nimport functionsDomain from \"@penrose/examples/dist/set-theory-domain/functions.domain\";\nimport setTheory from \"@penrose/examples/dist/set-theory-domain/setTheory.domain\";\nimport venn from \"@penrose/examples/dist/set-theory-domain/venn.style\";\n\nexport const error = {\n  domain: `typeppp Set`,\n  substancce: `Set A + B`,\n  style: `\n  Set a {\n\n  }\n  `,\n};\nexport const oneSet = {\n  domain: setTheory,\n  substance: `\nSet A\nAutoLabel All\n`,\n  style: venn,\n  variation: \"\",\n};\n\nexport const continuousMap = {\n  substance: continuousMapSubstance,\n  style: continuousMapStyle,\n  domain: functionsDomain,\n  variation: \"\",\n};\n\nexport const vectorWedge = {\n  variation: \"ArtemisCrane740\",\n  domain: exteriorAlgebraDomain,\n  substance: vectorWedgeSubstance,\n  style: exteriorAlgebraStyle,\n};\n\nexport const vectorsPerp = {\n  variation: \"MyrtleApe55311\",\n  domain: linearAlgebraDomain,\n  substance: twoVectorsPerpSubstance,\n  style: linearAlgebraStyle,\n};\n"],"names":["linearAlgebraStyle","linearAlgebraDomain","twoVectorsPerpSubstance","continuousMapStyle","continuousMapSubstance","functionsDomain","setTheory","venn","error","domain","substancce","style","oneSet","substance","variation","continuousMap","vectorWedge","exteriorAlgebraDomain","vectorWedgeSubstance","exteriorAlgebraStyle","vectorsPerp"],"mappings":"uEAEA,MAAAA,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECFfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECEfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCFfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eCAfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA,ECEfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECUFC,EAAQ,CACnBC,OAAS,cACTC,WAAa,YACbC,MAAQ;AAAA;AAAA;AAAA;AAAA,GAKV,EACaC,EAAS,CACpBH,OAAQH,EACRO,UAAY;AAAA;AAAA;AAAA,EAIZF,MAAOJ,EACPO,UAAW,EACb,EAEaC,EAAgB,CAC3BF,UAAWT,EACXO,MAAOR,EACPM,OAAQJ,EACRS,UAAW,EACb,EAEaE,EAAc,CACzBF,UAAW,kBACXL,OAAQQ,EACRJ,UAAWK,EACXP,MAAOQ,CACT,EAEaC,EAAc,CACzBN,UAAW,iBACXL,OAAQR,EACRY,UAAWX,EACXS,MAAOX,CACT"}