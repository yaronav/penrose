{"version":3,"file":"Simple-c9a21b09.js","sources":["../../../core/dist/utils/CollectLabels.js","../../../core/dist/renderer/AttrMapSvg.js","../../../core/dist/renderer/AttrHelper.js","../../../core/dist/renderer/Circle.js","../../../core/dist/renderer/Ellipse.js","../../../core/dist/renderer/Equation.js","../../../core/dist/renderer/not_found.js","../../../core/dist/renderer/util.js","../../../core/dist/renderer/Image.js","../../../core/dist/renderer/Line.js","../../../core/dist/renderer/Path.js","../../../core/dist/renderer/Polygon.js","../../../core/dist/renderer/Polyline.js","../../../core/dist/renderer/Rectangle.js","../../../core/dist/renderer/Text.js","../../../core/dist/renderer/dragUtils.js","../../../core/dist/renderer/Renderer.js","../../../core/dist/index.js","../../src/fetchPathResolver.ts","../../src/Simple.tsx"],"sourcesContent":["import { browserAdaptor } from \"mathjax-full/js/adaptors/browserAdaptor.js\";\nimport { RegisterHTMLHandler } from \"mathjax-full/js/handlers/html.js\";\nimport { TeX } from \"mathjax-full/js/input/tex.js\";\nimport { AllPackages } from \"mathjax-full/js/input/tex/AllPackages.js\";\nimport { mathjax } from \"mathjax-full/js/mathjax.js\";\nimport { SVG } from \"mathjax-full/js/output/svg.js\";\nimport { err, ok } from \"./Error.js\";\nimport { getAdValueAsString, getValueAsShapeList, unwrap } from \"./Util.js\";\nexport const mathjaxInit = () => {\n    // https://github.com/mathjax/MathJax-demos-node/blob/master/direct/tex2svg\n    // const adaptor = chooseAdaptor();\n    const adaptor = browserAdaptor();\n    RegisterHTMLHandler(adaptor);\n    const tex = new TeX({\n        packages: AllPackages,\n        macros: {\n            textsc: [\"\\\\style{font-variant-caps: small-caps}{\\\\text{#1}}\", 1],\n        },\n        inlineMath: [\n            [\"$\", \"$\"],\n            [\"\\\\(\", \"\\\\)\"],\n        ],\n        processEscapes: true,\n        // https://github.com/mathjax/MathJax-demos-node/issues/25#issuecomment-711247252\n        formatError: (jax, err) => {\n            throw Error(err.message);\n        },\n    });\n    const svg = new SVG({ fontCache: \"none\" });\n    const html = mathjax.document(\"\", { InputJax: tex, OutputJax: svg });\n    const convert = (input) => {\n        // HACK: workaround for newlines. This workaround will force MathJax to always return the same heights regardless of the text content.\n        // https://github.com/mathjax/MathJax/issues/2312#issuecomment-538185951\n        // if(input) {\n        //   const newline_escaped = `\\\\displaylines{${input}}`;\n        // }\n        try {\n            const node = html.convert(input, {});\n            return ok(node.firstChild);\n        }\n        catch (error) {\n            return err(error.message);\n        }\n    };\n    return convert;\n};\nconst parseFontSize = (fontSize) => {\n    const regex = /^(\\d+(?:\\.\\d+)?)\\s*(px|in|cm|mm)$/;\n    const match = fontSize.match(regex);\n    if (!match) {\n        return;\n    }\n    const number = parseFloat(match[1]);\n    const unit = match[2];\n    return { number, unit };\n};\n// Convert from a font size in absolute unit (px, in, cm, mm) to pixels\nconst toPxFontSize = (number, unit) => {\n    const inPX = {\n        px: 1,\n        in: 96,\n        cm: 96 / 2.54,\n        mm: 96 / 25.4, // 10 mm to a cm\n    };\n    return inPX[unit] * number;\n};\n/**\n * Call MathJax to render __non-empty__ labels.\n */\nconst tex2svg = async (properties, convert) => new Promise((resolve) => {\n    const contents = getAdValueAsString(properties.string, \"\");\n    const fontSize = getAdValueAsString(properties.fontSize, \"\");\n    // Raise error if string or fontSize are empty or optimized\n    if (fontSize === \"\" || contents === \"\") {\n        resolve(err(`Label 'string' and 'fontSize' must be non-empty and non-optimized for ${properties.name.contents}`));\n    }\n    // Render the label\n    const output = convert(contents);\n    if (output.isErr()) {\n        resolve(err(`MathJax could not render $${contents}$: ${output.error}`));\n        return;\n    }\n    const body = output.value;\n    const viewBox = body.getAttribute(\"viewBox\");\n    if (viewBox === null) {\n        resolve(err(`No ViewBox found for MathJax output $${contents}$`));\n        return;\n    }\n    // Get re-scaled dimensions of label according to\n    // https://github.com/mathjax/MathJax-src/blob/32213009962a887e262d9930adcfb468da4967ce/ts/output/svg.ts#L248\n    // all viewbox units are divided by 1000 because MathJax scaled them by 1000\n    // these viewbox props are in em units * 1000\n    const viewBoxArr = viewBox.split(\" \");\n    const width = parseFloat(viewBoxArr[2]) / 1000;\n    const height = parseFloat(viewBoxArr[3]) / 1000;\n    // the vertical align adjustment and height in ex unit. This is used to avoid dealing with ex to px conversion\n    const d = -parseFloat(body.style.verticalAlign);\n    const exH = parseFloat(body.getAttribute(\"height\"));\n    // em is really the pixel value of the font size\n    const parsedFontSize = parseFontSize(fontSize);\n    if (parsedFontSize) {\n        const { number, unit } = parsedFontSize;\n        const em_to_px = (n) => n * toPxFontSize(number, unit);\n        const scaledWidth = em_to_px(width);\n        const scaledHeight = em_to_px(height);\n        const scaledD = (d / exH) * scaledHeight;\n        const scaledDescent = scaledD;\n        const scaledAscent = scaledHeight - scaledDescent; // HACK: interpreting ascent to be height - descent, which might be very wrong\n        resolve(ok({\n            body,\n            width: scaledWidth,\n            height: scaledHeight,\n            descent: scaledDescent,\n            ascent: scaledAscent,\n        }));\n    }\n    else {\n        resolve(err('Invalid font size format. Only \"px\", \"in\", \"cm\", and \"mm\" units are supported.'));\n        return;\n    }\n});\nconst floatV = (contents) => ({\n    tag: \"FloatV\",\n    contents,\n});\nconst textData = (width, height, descent, ascent) => ({\n    tag: \"TextData\",\n    width: floatV(width),\n    height: floatV(height),\n    descent: floatV(descent),\n    ascent: floatV(ascent),\n});\nconst equationData = (width, height, ascent, descent, rendered) => ({\n    tag: \"EquationData\",\n    width: floatV(width),\n    height: floatV(height),\n    ascent: floatV(ascent),\n    descent: floatV(descent),\n    rendered,\n});\n/**\n * Get the CSS string for the font setting of a `Text` shape.\n * @param shape A text shape\n *\n * NOTE: the `font` CSS rule -> https://developer.mozilla.org/en-US/docs/Web/CSS/font\n *\n * @returns a CSS rule string of its font settings\n */\nexport const toFontRule = (properties) => {\n    const fontFamily = getAdValueAsString(properties.fontFamily);\n    const fontSize = getAdValueAsString(properties.fontSize);\n    const fontStretch = getAdValueAsString(properties.fontStretch);\n    const fontStyle = getAdValueAsString(properties.fontStyle);\n    const fontVariant = getAdValueAsString(properties.fontVariant);\n    const fontWeight = getAdValueAsString(properties.fontWeight);\n    const lineHeight = getAdValueAsString(properties.lineHeight);\n    /**\n     * assemble according to the rules in https://developer.mozilla.org/en-US/docs/Web/CSS/font\n     * it must include values for: <font-size> <font-family>\n     * it may optionally include values for: <font-style> <font-variant> <font-weight> <font-stretch> <line-height>\n     * font-style, font-variant and font-weight must precede font-size\n     * font-variant may only specify the values defined in CSS 2.1, that is normal and small-caps\n     * font-stretch may only be a single keyword value.\n     * line-height must immediately follow font-size, preceded by \"/\", like this: \"16px/3\"\n     * font-family must be the last value specified.\n     */\n    const fontSpec = `${fontStretch} ${fontStyle} ${fontVariant} ${fontWeight} ${fontSize} ${fontFamily}`;\n    const fontString = lineHeight !== \"\" ? fontSpec.concat(`/${lineHeight}`) : fontSpec;\n    return fontString;\n};\n// https://stackoverflow.com/a/44564236\nexport const collectLabels = async (allShapes, convert) => {\n    const labels = new Map();\n    for (const s of allShapes) {\n        if (s.shapeType === \"Equation\") {\n            const shapeName = getAdValueAsString(s.name);\n            const svg = await tex2svg(s, convert);\n            if (svg.isErr()) {\n                return err({\n                    errorType: \"SubstanceError\",\n                    tag: \"Fatal\",\n                    message: svg.error,\n                });\n            }\n            const { body, width, height, ascent, descent } = svg.value;\n            // Instead of directly overwriting the properties, cache them temporarily\n            // NOTE: in the case of empty strings, `tex2svg` returns infinity sometimes. Convert to 0 to avoid NaNs in such cases.\n            const label = equationData(width === Infinity ? 0 : width, height === Infinity ? 0 : height, ascent, descent, body);\n            labels.set(shapeName, label);\n        }\n        else if (s.shapeType === \"Text\") {\n            const shapeName = getAdValueAsString(s.name);\n            let label;\n            // Use canvas to measure text data\n            const measure = measureText(getAdValueAsString(s.string), toFontRule(s));\n            // If the width and height are defined, the renderer will render the text. `actualDescent` is currently not used in rendering.\n            if (measure.width && measure.height) {\n                label = textData(measure.width, measure.height, measure.actualDescent, measure.actualAscent);\n            }\n            else {\n                label = textData(0, 0, 0, 0);\n            }\n            labels.set(shapeName, label);\n        }\n        else if (s.shapeType === \"Group\") {\n            const subShapes = getValueAsShapeList(s.shapes);\n            const subLabels = await collectLabels(subShapes, convert);\n            if (subLabels.isErr()) {\n                return subLabels;\n            }\n            for (const [key, value] of subLabels.value.entries()) {\n                labels.set(key, value);\n            }\n        }\n    }\n    return ok(labels);\n};\n/**\n *\n * @param text the content of the text\n * @param font the CSS font rule for the text\n *\n * NOTE: the `font` CSS rule -> https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @returns `TextMeasurement` object and includes data such as `width` and `height` of the text.\n */\nexport function measureText(text, font) {\n    const measureTextElement = document.createElement(\"canvas\");\n    const measureTextContext = measureTextElement.getContext(\"2d\");\n    measureTextContext.textBaseline = \"alphabetic\";\n    measureTextContext.font = font;\n    const measurements = measureTextContext.measureText(text);\n    measureTextElement.remove();\n    return {\n        width: Math.abs(measurements.actualBoundingBoxLeft) +\n            Math.abs(measurements.actualBoundingBoxRight),\n        height: Math.abs(measurements.actualBoundingBoxAscent) +\n            Math.abs(measurements.actualBoundingBoxDescent),\n        actualDescent: Math.abs(measurements.actualBoundingBoxDescent),\n        actualAscent: Math.abs(measurements.actualBoundingBoxAscent),\n    };\n}\nconst setPendingProperty = (xs, inputs, before, after) => {\n    if (typeof before.contents !== \"number\" && before.contents.tag === \"Var\") {\n        const { index, meta } = unwrap(inputs.get(before.contents), () => \"missing input\");\n        if (meta.init.tag === \"Pending\")\n            xs[index] = after.contents;\n    }\n};\nconst insertPendingHelper = (shapes, xs, labelCache, inputs) => {\n    for (const s of shapes) {\n        if (s.shapeType === \"Group\") {\n            const subShapes = getValueAsShapeList(s.shapes);\n            insertPendingHelper(subShapes, xs, labelCache, inputs);\n        }\n        else if (s.shapeType === \"Equation\") {\n            const labelData = unwrap(labelCache.get(s.name.contents), () => `missing label: ${s.name.contents}. Label cache: ${[\n                ...labelCache.keys(),\n            ].join(\" \")}`);\n            if (labelData.tag !== \"EquationData\")\n                throw Error(`for ${s.shapeType} ${s.name.contents} got unexpected ${labelData.tag}`);\n            setPendingProperty(xs, inputs, s.width, labelData.width);\n            setPendingProperty(xs, inputs, s.height, labelData.height);\n            setPendingProperty(xs, inputs, s.ascent, labelData.ascent);\n            setPendingProperty(xs, inputs, s.descent, labelData.descent);\n        }\n        else if (s.shapeType === \"Text\") {\n            const labelData = unwrap(labelCache.get(s.name.contents), () => `missing label: ${s.name.contents}`);\n            if (labelData.tag !== \"TextData\")\n                throw Error(`for ${s.shapeType} ${s.name.contents} got unexpected ${labelData.tag}`);\n            setPendingProperty(xs, inputs, s.width, labelData.width);\n            setPendingProperty(xs, inputs, s.height, labelData.height);\n            setPendingProperty(xs, inputs, s.ascent, labelData.ascent);\n            setPendingProperty(xs, inputs, s.descent, labelData.descent);\n        }\n    }\n};\nexport const insertLabelMeasurements = (state) => {\n    const varyingValues = [...state.varyingValues];\n    const inputs = new Map(state.inputs.map(({ handle, meta }, index) => [handle, { index, meta }]));\n    insertPendingHelper(state.shapes, varyingValues, state.labelCache, inputs);\n    return { ...state, varyingValues };\n};\n//# sourceMappingURL=CollectLabels.js.map","/**\n * Mapping from internal \"non-kebab\" Penrose names to SVG \"kebab\" names\n */\nexport const attrMapSvg = {\n    accentHeight: \"accent-height\",\n    alignmentBaseline: \"alignment-baseline\",\n    arabicForm: \"arabic-form\",\n    baselineShift: \"baseline-shift\",\n    capHeight: \"cap-height\",\n    clipPath: \"clip-path\",\n    clipRule: \"clip-rule\",\n    colorInterpolation: \"color-interpolation\",\n    colorInterpolationFilters: \"color-interpolation-filters\",\n    colorProfile: \"color-profile\",\n    colorRendering: \"color-rendering\",\n    dominantBaseline: \"dominant-baseline\",\n    enableBackground: \"enable-background\",\n    fillOpacity: \"fill-opacity\",\n    fillRule: \"fill-rule\",\n    floodColor: \"flood-color\",\n    floodOpacity: \"flood-opacity\",\n    fontFamily: \"font-family\",\n    fontSize: \"font-size\",\n    fontSizeAdjust: \"font-size-adjust\",\n    fontStretch: \"font-stretch\",\n    fontStyle: \"font-style\",\n    fontVariant: \"font-variant\",\n    fontWeight: \"font-weight\",\n    glyphName: \"glyph-name\",\n    glyphOrientationHorizontal: \"glyph-orientation-horizontal\",\n    glyphOrientationVertical: \"glyph-orientation-vertical\",\n    horizAdvX: \"horiz-adv-x\",\n    horizOriginX: \"horiz-origin-x\",\n    imageRendering: \"image-rendering\",\n    letterSpacing: \"letter-spacing\",\n    lightingColor: \"lighting-color\",\n    markerEnd: \"marker-end\",\n    markerMid: \"marker-mid\",\n    markerStart: \"marker-start\",\n    overlinePosition: \"overline-position\",\n    overlineThickness: \"overline-thickness\",\n    panose1: \"panose-1\",\n    paintOrder: \"paint-order\",\n    pointerEvents: \"pointer-events\",\n    renderingIntent: \"rendering-intent\",\n    shapeRendering: \"shape-rendering\",\n    stopColor: \"stop-color\",\n    stopOpacity: \"stop-opacity\",\n    strikethroughPosition: \"strikethrough-position\",\n    strikethroughThickness: \"strikethrough-thickness\",\n    strokeDasharray: \"stroke-dasharray\",\n    strokeDashoffset: \"stroke-dashoffset\",\n    strokeLinecap: \"stroke-linecap\",\n    strokeLinejoin: \"stroke-linejoin\",\n    strokeMiterlimit: \"stroke-miterlimit\",\n    strokeOpacity: \"stroke-opacity\",\n    strokeWidth: \"stroke-width\",\n    textAnchor: \"text-anchor\",\n    textDecoration: \"text-decoration\",\n    textRendering: \"text-rendering\",\n    transformOrigin: \"transform-origin\",\n    underlinePosition: \"underline-position\",\n    underlineThickness: \"underline-thickness\",\n    unicodeBidi: \"unicode-bidi\",\n    unicodeRange: \"unicode-range\",\n    unitsPerEm: \"units-per-em\",\n    vAlphabetic: \"v-alphabetic\",\n    vHanging: \"v-hanging\",\n    vIdeographic: \"v-ideographic\",\n    vMathematical: \"v-mathematical\",\n    vectorEffect: \"vector-effect\",\n    vertAdvY: \"vert-adv-y\",\n    vertOriginX: \"vert-origin-x\",\n    vertOriginY: \"vert-origin-y\",\n    wordSpacing: \"word-spacing\",\n    writingMode: \"writing-mode\",\n};\n//# sourceMappingURL=AttrMapSvg.js.map","/**\n * Provides an assortment of utility functions shared across shapes that computes\n * output SVG properties using the optimized shape properties as input.\n */\nimport { toFontRule } from \"../utils/CollectLabels.js\";\nimport { isKeyOf, toScreen, toSvgOpacityProperty, toSvgPaintProperty, } from \"../utils/Util.js\";\nimport { attrMapSvg } from \"./AttrMapSvg.js\";\n/**\n * Auto-map to SVG any input properties for which we lack specific logic.\n *\n * Apply a map, AttrMapSvg, to perform any target-specific property name translation,\n * i.e., map from Penrose camel case format to SVG mixed-case/kebab format.  Property names\n * not found in the map are mapped straight across.\n *\n * Note: Right now we are neither validating the SVG property names nor its contents.  The\n * thinking is to add an optional validator to the end of the pipeline at some point rather\n * than implement validation for all passthrough SVG properties inside Penrose.\n *\n * Note: This is an \"escape hatch\" for \"passthrough\" SVG properties we don't currently support.\n *\n * Note: SVG property names are case sensitive.\n */\nexport const attrAutoFillSvg = (shape, elem, attrAlreadyMapped) => {\n    // Internal properties to never auto-map to SVG\n    const attrToNeverAutoMap = [\"name\", \"ensureOnCanvas\"];\n    // Merge the mapped and never-map properties.  Convert to Set\n    const attrToNotAutoMap = new Set(attrAlreadyMapped.concat(attrToNeverAutoMap));\n    // Map unknown/unseen attributes with values to SVG output.\n    // This is the \"escape hatch\" for properties we don't support.\n    //\n    // NOTE: `style` is handled as a special case, because some of\n    // the built-in properties will write to it __and__ the user\n    // should be able to append to it. Therefore, we check if there's\n    // an existing value in `style` and append to it if true.\n    for (const [propKey, propVal] of shape.passthrough) {\n        if ((propVal.tag === \"StrV\" && propVal.contents === \"\") ||\n            attrToNotAutoMap.has(propKey))\n            continue;\n        if (isKeyOf(propKey, attrMapSvg)) {\n            const mappedPropKey = attrMapSvg[propKey];\n            if (!elem.hasAttribute(mappedPropKey)) {\n                elem.setAttribute(mappedPropKey, propVal.contents.toString());\n            }\n        }\n        else if (propKey === \"style\" && propVal.contents !== \"\") {\n            const style = elem.getAttribute(propKey);\n            if (style === null) {\n                elem.setAttribute(propKey, propVal.contents.toString());\n            }\n            else {\n                elem.setAttribute(propKey, `${style}${propVal.contents.toString()}`);\n            }\n        }\n        else {\n            if (!elem.hasAttribute(propKey)) {\n                elem.setAttribute(propKey, propVal.contents.toString());\n            }\n        }\n    }\n};\n/**\n * Maps fillColor --> fill, fill-opacity\n */\nexport const attrFill = (properties, elem) => {\n    const color = properties.fillColor;\n    const alpha = toSvgOpacityProperty(color.contents);\n    elem.setAttribute(\"fill\", toSvgPaintProperty(color.contents));\n    // Fill opacity only relevant if fill is present\n    if (color.contents.tag !== \"NONE\") {\n        elem.setAttribute(\"fill-opacity\", alpha.toString());\n    }\n    return [\"fillColor\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps center --> cx, cy\n */\nexport const attrCenter = (properties, canvasSize, elem) => {\n    const center = properties.center;\n    const [x, y] = toScreen([center.contents[0], center.contents[1]], canvasSize);\n    elem.setAttribute(\"cx\", x.toString());\n    elem.setAttribute(\"cy\", y.toString());\n    return [\"center\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps scale --> transform\n */\nexport const attrScale = (properties, elem) => {\n    let scale = properties.scale.contents;\n    scale = scale || 1;\n    let transform = elem.getAttribute(\"transform\");\n    transform =\n        transform === null ? `scale(${scale})` : transform + `scale{${scale}}`;\n    elem.setAttribute(\"transform\", transform);\n    return [\"scale\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps center, width, height --> transform\n */\nexport const attrTransformCoords = (properties, canvasSize, elem) => {\n    const center = properties.center;\n    const [x, y] = toScreen([center.contents[0], center.contents[1]], canvasSize);\n    const w = properties.width;\n    const h = properties.height;\n    let transform = elem.getAttribute(\"transform\");\n    transform =\n        transform === null\n            ? `translate(${x - w.contents / 2}, ${y - h.contents / 2})`\n            : transform + `translate(${x - w.contents / 2}, ${y - h.contents / 2})`;\n    elem.setAttribute(\"transform\", transform);\n    return [\"center\", \"width\", \"height\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps center, width, height --> x, y\n */\nexport const attrXY = (properties, canvasSize, elem) => {\n    const center = properties.center;\n    const [x, y] = toScreen([center.contents[0], center.contents[1]], canvasSize);\n    const w = properties.width;\n    const h = properties.height;\n    elem.setAttribute(\"x\", (x - w.contents / 2).toString());\n    elem.setAttribute(\"y\", (y - h.contents / 2).toString());\n    return [\"center\", \"width\", \"height\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps center, width, height, rotation --> transform\n *\n * Rotates a GPI by n degrees about a center\n * Note: elem must be `transform`able\n * NOTE: must be called before transform translate coords (matrix rules)\n * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform\n */\nexport const attrRotation = (properties, canvasSize, elem) => {\n    const w = properties.width;\n    const h = properties.height;\n    const center = properties.center;\n    const rotation = properties.rotation.contents;\n    const [x, y] = toScreen([center.contents[0], center.contents[1]], canvasSize);\n    let transform = elem.getAttribute(\"transform\");\n    transform =\n        transform === null\n            ? `rotate(${rotation}, ${x}, ${y})`\n            : transform + `rotate(${rotation}, ${x}, ${y})`;\n    elem.setAttribute(\"transform\", transform);\n    return [\"rotation\", \"center\", \"width\", \"height\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps width, height --> width, height\n */\nexport const attrWH = (properties, elem) => {\n    const w = properties.width;\n    const h = properties.height;\n    elem.setAttribute(\"width\", Math.max(w.contents, 0).toString());\n    elem.setAttribute(\"height\", Math.max(h.contents, 0).toString());\n    return [\"width\", \"height\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps cornerRadius --> rx\n */\nexport const attrCornerRadius = (properties, elem) => {\n    const rx = properties.cornerRadius;\n    elem.setAttribute(\"rx\", rx.contents.toString());\n    return [\"cornerRadius\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps string --> new TextNode\n */\nexport const attrString = (properties, elem) => {\n    const str = properties.string;\n    const text = document.createTextNode(str.contents.toString());\n    elem.appendChild(text);\n    return [\"string\"]; // Return array of input properties programatically mapped\n};\nexport const DASH_ARRAY = \"7,5\";\n/**\n * Maps strokeColor --> stroke, stroke-opacity\n *      strokeWidth --> stroke-width\n *      strokeDasharray, strokeStyle --> stroke-dasharray\n *      strokeLinecap --> stroke-linecap\n */\nexport const attrStroke = (properties, elem) => {\n    // Keep a list of which input properties we programatically mapped\n    const attrMapped = [];\n    const strokeColor = properties.strokeColor;\n    const strokeAlpha = toSvgOpacityProperty(strokeColor.contents);\n    const thickness = properties.strokeWidth.contents;\n    elem.setAttribute(\"stroke\", toSvgPaintProperty(strokeColor.contents));\n    attrMapped.push(\"strokeColor\", \"strokeWidth\");\n    // Stroke opacity, width, and dashiness only relevant if stroke is present\n    if (strokeColor.contents.tag !== \"NONE\") {\n        elem.setAttribute(\"stroke-opacity\", strokeAlpha.toString());\n        elem.setAttribute(\"stroke-width\", thickness.toString());\n        if (\"strokeDasharray\" in properties &&\n            properties.strokeDasharray.contents !== \"\") {\n            elem.setAttribute(\"stroke-dasharray\", properties.strokeDasharray.contents);\n            attrMapped.push(\"strokeDasharray\");\n        }\n        else if (\"strokeStyle\" in properties &&\n            properties.strokeStyle.contents === \"dashed\") {\n            elem.setAttribute(\"stroke-dasharray\", DASH_ARRAY.toString());\n            attrMapped.push(\"strokeDasharray\", \"strokeStyle\");\n        }\n        // NOTE: some stroked properties might not contain `strokeLinecap`\n        if (\"strokeLinecap\" in properties &&\n            properties.strokeLinecap.contents !== \"\") {\n            elem.setAttribute(\"stroke-linecap\", properties.strokeLinecap.contents);\n            attrMapped.push(\"strokeLinecap\");\n        }\n    }\n    return attrMapped; // Return array of input properties programatically mapped\n};\n/**\n * Maps name --> new Title\n */\nexport const attrTitle = (properties, elem) => {\n    const name = properties.name;\n    const title = document.createElementNS(\"http://www.w3.org/2000/svg\", \"title\");\n    title.textContent = name.contents;\n    elem.appendChild(title);\n    return [\"name\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps fontFamily, fontSize, fontStretch, fontStyle, fontVariant, fontWeight, lineHeight -> font\n */\nexport const attrFont = (shape, elem) => {\n    const fontString = toFontRule(shape);\n    const existingStyle = elem.getAttribute(\"style\");\n    // TODO: check if `lineHeight` is valid\n    elem.setAttribute(\"style\", existingStyle\n        ? `${existingStyle}; font: ${fontString};`\n        : `font: ${fontString};`);\n    return [\n        \"fontFamily\",\n        \"fontSize\",\n        \"fontStretch\",\n        \"fontStyle\",\n        \"fontVariant\",\n        \"fontWeight\",\n        \"lineHeigh\",\n    ]; // Return array of input properties programatically mapped\n};\n/**\n * Maps points -> points\n */\nexport const attrPolyPoints = (shape, canvasSize, elem) => {\n    const points = shape.points;\n    const pointsTransformed = points.contents.map((p) => toScreen([p[0], p[1]], canvasSize));\n    elem.setAttribute(\"points\", pointsTransformed.toString());\n    return [\"points\"];\n};\n//# sourceMappingURL=AttrHelper.js.map","import { attrAutoFillSvg, attrCenter, attrFill, attrStroke, attrTitle, } from \"./AttrHelper.js\";\nconst RenderCircle = (shape, { canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Fill the output SVG attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrCenter(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    elem.setAttribute(\"r\", Math.max(0, shape.r.contents).toString());\n    attrToNotAutoMap.push(\"r\");\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderCircle;\n//# sourceMappingURL=Circle.js.map","import { attrAutoFillSvg, attrCenter, attrFill, attrStroke, attrTitle, } from \"./AttrHelper.js\";\nconst RenderEllipse = (shape, { canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"ellipse\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrCenter(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    elem.setAttribute(\"rx\", Math.max(shape.rx.contents, 0).toString());\n    attrToNotAutoMap.push(\"rx\");\n    elem.setAttribute(\"ry\", Math.max(shape.ry.contents, 0).toString());\n    attrToNotAutoMap.push(\"ry\");\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderEllipse;\n//# sourceMappingURL=Ellipse.js.map","import { getAdValueAsString, toScreen } from \"../utils/Util.js\";\nimport { attrAutoFillSvg, attrFill, attrRotation, attrTitle, attrTransformCoords, attrWH, } from \"./AttrHelper.js\";\nconst placeholderString = (label, [x, y], shape) => {\n    const txt = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    // fake font\n    txt.textContent = label;\n    attrFill(shape, txt);\n    attrWH(shape, txt);\n    txt.setAttribute(\"x\", `${x}`);\n    txt.setAttribute(\"y\", `${y}`);\n    txt.setAttribute(\"alignment-baseline\", \"alphabetic\");\n    txt.setAttribute(\"dominant-baseline\", \"alphabetic\");\n    txt.setAttribute(\"text-anchor\", \"middle\");\n    return txt;\n};\nconst RenderEquation = (shape, renderOptions) => {\n    const { canvasSize, labels, texLabels } = renderOptions;\n    const { center } = shape;\n    const [x, y] = toScreen([center.contents[0], center.contents[1]], canvasSize);\n    if (texLabels) {\n        // If equations are rendered as plain TeX strings, forward relevant props to a <text> element and surround the TeX string with $$\n        // Since the `svg` TeX package render text with the center on the baseline, we shift the labels down by height/2 + descent\n        const baselineY = y + shape.height.contents / 2 - shape.descent.contents;\n        let txt = placeholderString(`$${getAdValueAsString(shape.string)}$`, [x, baselineY], shape);\n        // If the Equation has a texContourColor passthrough value, give the\n        // string a contour with the specified color\n        for (const [propKey, propVal] of shape.passthrough) {\n            if (propKey === \"texContourColor\" && propVal.contents !== \"\") {\n                txt = placeholderString(`\\\\contour{${propVal.contents}}{$${getAdValueAsString(shape.string)}$}`, [x, baselineY], shape);\n            }\n        }\n        return txt;\n    }\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrRotation(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrTransformCoords(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    const retrievedLabel = labels.get(getAdValueAsString(shape.name));\n    // If pre-rendered label was found, render the label in a group\n    if (retrievedLabel && retrievedLabel.tag === \"EquationData\") {\n        // Clone the retrieved node first to avoid mutating existing labels\n        const renderedLabel = retrievedLabel.rendered.cloneNode(true);\n        const g = renderedLabel.getElementsByTagName(\"g\")[0];\n        attrToNotAutoMap.push(...attrFill(shape, g));\n        // Map Width/Height\n        attrToNotAutoMap.push(...attrWH(shape, renderedLabel));\n        g.setAttribute(\"stroke\", \"none\");\n        g.setAttribute(\"stroke-width\", \"0\");\n        const fontSize = shape.fontSize;\n        renderedLabel.setAttribute(\"style\", `font-size: ${fontSize.contents}`);\n        // Append the element & indicate the rendered label was found\n        elem.appendChild(renderedLabel);\n        // Directly Map across any \"unknown\" SVG properties\n        attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n        return elem;\n    }\n    else {\n        // Fallback case: generate plain-text (non-rendered) label from string\n        return placeholderString(getAdValueAsString(shape.string), [x, y], shape);\n    }\n};\nexport default RenderEquation;\n//# sourceMappingURL=Equation.js.map","export const image = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg id=\"uuid-14337243-9689-41d7-b7ce-2960e3a1016a\" data-name=\"uuid-95bf6e06-fb2b-43f6-8f44-0afdfcaaf242\" xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"200\" viewBox=\"0 0 200 200\">\n  <polygon points=\"132.5 2.1 175.7 45.3 175.7 197.9 24.3 197.9 24.3 2.1 132.5 2.1\" style=\"fill: #e0e0e0; stroke: #7f7f7f; stroke-width: 4.039px;\"/>\n  <g>\n    <path d=\"m157.4,77.75l-46.2-33.4-42.1,30.4m42.2-46.9l-46.4,33.5,15.7,49.1m38.2,0h-51.4l-18-54.1m7.8,66.9h57.1l17.1-48.4m-7.3,62l17.9-54.1-42.2-30.9m38,85H61.6l-23.4-72.3,61.5-44.9,62.1,44.9-24,72.3Z\" style=\"fill: none; stroke: #ffb6b6; stroke-width: 4.034px;\"/>\n    <path d=\"m77,66.3c0-3.4.5-6.5,1.4-9.4s2.3-5.3,4.2-7.3c1.8-2,4.2-3.6,7-4.8s6.1-1.7,9.7-1.7c8,0,13.9,2,17.9,5.9,3.9,3.9,5.9,9.2,5.9,15.8,0,3.2-.5,6.1-1.5,8.8s-2.9,5.6-5.6,8.8l-4.5,5.1c-2,2.2-3.4,4.2-4.2,6-.9,1.8-1.3,4.1-1.3,7h0c0,.9-.8,1.7-1.7,1.7h-10.7c-.9,0-1.7-.8-1.7-1.7v-2.7c0-3.8.5-6.9,1.6-9.5s2.9-5.3,5.4-8.2l4.3-4.8c1.6-1.7,2.7-3.6,3.3-5.6.6-2,1-4.1,1-6.4,0-2.9-.6-5.2-1.9-6.9-1.3-1.8-3.2-2.6-5.7-2.6-2.9,0-4.9,1.1-6.1,3.4-1.2,2.3-1.9,5.3-1.9,9v1.1c0,.9-.8,1.7-1.7,1.7h-11.6c-.9,0-1.7-.8-1.7-1.7v-1h.1Zm28,58.1h-12.2c-.9,0-1.7-.8-1.7-1.7v-11.5c0-.9.8-1.7,1.7-1.7h12.2c.9,0,1.7.8,1.7,1.7v11.5c0,1-.8,1.7-1.7,1.7Z\" style=\"fill: red;\"/>\n  </g>\n  <g style=\"isolation: isolate;\">\n    <g style=\"isolation: isolate;\">\n      <path d=\"m58.52,179.451h-8.066v-9.533h8.066v9.533Z\"/>\n      <path d=\"m70.802,169.795c0,1.427.376,2.577,1.131,3.453.753.876,1.843,1.313,3.269,1.313,1.303,0,2.342-.325,3.117-.978.773-.651,1.161-1.629,1.161-2.934,0-1.059-.306-1.863-.917-2.414-.611-.55-1.324-.987-2.139-1.313l-5.928-2.139c-2.322-.814-4.074-1.965-5.255-3.453-1.182-1.486-1.772-3.392-1.772-5.713,0-1.345.224-2.617.672-3.819.448-1.201,1.161-2.251,2.139-3.147.978-.896,2.23-1.609,3.758-2.139s3.371-.795,5.53-.795c3.829,0,6.661.815,8.494,2.444,1.833,1.63,2.75,3.933,2.75,6.905v1.345h-7.578c0-1.711-.275-2.964-.825-3.758-.55-.795-1.519-1.192-2.903-1.192-1.06,0-1.986.296-2.781.887-.794.591-1.191,1.477-1.191,2.658,0,.815.254,1.549.764,2.199.509.652,1.477,1.202,2.903,1.65l5.072,1.711c2.647.896,4.522,2.068,5.622,3.514,1.1,1.447,1.65,3.413,1.65,5.897,0,1.752-.306,3.27-.917,4.553-.611,1.283-1.457,2.353-2.536,3.208-1.08.855-2.363,1.467-3.85,1.833-1.488.367-3.127.55-4.919.55-2.363,0-4.329-.224-5.897-.672-1.569-.448-2.811-1.12-3.728-2.017-.917-.896-1.558-1.986-1.925-3.27s-.55-2.719-.55-4.308v-1.161h7.578v1.1Z\"/>\n      <path d=\"m115.778,146.574l-8.25,32.877h-9.778l-8.494-32.877h8.8l4.705,23.527h.123l4.461-23.527h8.434Z\"/>\n      <path d=\"m143.52,177.8c0,4.237-1.049,7.415-3.146,9.533-2.099,2.118-5.612,3.178-10.541,3.178-3.586,0-6.347-.764-8.28-2.291-1.936-1.528-2.903-3.697-2.903-6.509h8.066c0,1.06.428,1.895,1.283,2.506.407.284.846.509,1.314.672.468.162.967.245,1.497.245,1.711,0,2.912-.551,3.605-1.65.692-1.1,1.038-2.466,1.038-4.095v-4.338h-.122c-.855,1.222-1.904,2.199-3.146,2.933-1.243.733-2.536,1.101-3.881,1.101-3.341,0-5.856-1.273-7.547-3.819-1.691-2.546-2.536-6.814-2.536-12.803,0-1.914.112-3.87.336-5.866s.692-3.799,1.406-5.408c.712-1.609,1.751-2.923,3.116-3.941,1.364-1.019,3.188-1.528,5.469-1.528,1.182,0,2.403.327,3.667.978,1.263.652,2.301,1.834,3.116,3.545h.122v-3.667h8.066v31.227Zm-16.713-10.511c.102,1.02.306,1.926.611,2.72.306.795.733,1.427,1.283,1.895.55.469,1.272.703,2.169.703s1.64-.234,2.23-.703c.591-.468,1.06-1.109,1.406-1.925.345-.814.59-1.803.732-2.964s.214-2.434.214-3.819c0-3.992-.315-6.823-.946-8.494-.633-1.67-1.783-2.506-3.453-2.506-.938,0-1.691.205-2.261.611-.571.408-1.02,1.069-1.345,1.986-.326.916-.54,2.139-.642,3.666-.103,1.528-.152,3.392-.152,5.592,0,1.141.05,2.221.152,3.238Z\"/>\n    </g>\n  </g>\n  <polygon points=\"175.7 45.3 132.5 45.3 132.5 2.1 175.7 45.3\" style=\"fill: #e0e0e0; stroke: #7f7f7f; stroke-linecap: round; stroke-linejoin: round; stroke-width: 4.039px;\"/>\n  <rect width=\"200\" height=\"200\" style=\"fill: none;\"/>\n</svg>`;\n//# sourceMappingURL=not_found.js.map","import { isKeyOf } from \"../utils/Util.js\";\n// Refactored version of `makeIdsUnique` in https://github.com/iconfu/svg-inject/blob/064ac002930deaf96eefb95eaf953c5ef5287992/src/svg-inject.js\n// MIT License\n// Copyright (c) 2018 INCORS GmbH, the creators of iconfu.com\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nlet uniqueIdCounter = 1;\n/**\n * Make all the IDs and references to them unique in an SVG element.\n * NOTE: this function mutates the SVG element\n * NOTE: this function doesn't behave well on a single SVG node (e.g. `<g>`). Therefore, we use this function for opaque imports (e.g. `Image`) and generally favor namespaces for id-uniqueness.\n * @param svgElem an SVG element\n * @param onlyReferenced only transform IDs that are referenced in the element\n * @returns whether the SVG element is changed\n */\nexport const makeIdsUnique = (svgElem, onlyReferenced) => {\n    const ID_SUFFIX = \"--inject-\";\n    // Map of IRI referenceable tag names to properties that can reference them. This is defined in\n    // https://www.w3.org/TR/SVG11/linking.html#processingIRI\n    const IRI_TAG_PROPERTIES_MAP = {\n        clipPath: [\"clip-path\"],\n        \"color-profile\": null,\n        cursor: null,\n        filter: null,\n        linearGradient: [\"fill\", \"stroke\"],\n        marker: [\"marker\", \"marker-end\", \"marker-mid\", \"marker-start\"],\n        mask: null,\n        pattern: [\"fill\", \"stroke\"],\n        radialGradient: [\"fill\", \"stroke\"],\n    };\n    const idSuffix = ID_SUFFIX + uniqueIdCounter++;\n    // Regular expression for functional notations of an IRI references. This will find occurences in the form\n    // url(#anyId) or url(\"#anyId\") (for Internet Explorer) and capture the referenced ID\n    const funcIriRegex = /url\\(\"?#([a-zA-Z][\\w:.-]*)\"?\\)/g;\n    // Get all elements with an ID. The SVG spec recommends to put referenced elements inside <defs> elements, but\n    // this is not a requirement, therefore we have to search for IDs in the whole SVG.\n    const idElements = svgElem.querySelectorAll(\"[id]\");\n    let idElem;\n    // An object containing referenced IDs  as keys is used if only referenced IDs should be uniquified.\n    // If this object does not exist, all IDs will be uniquified.\n    const referencedIds = onlyReferenced\n        ? new Set()\n        : undefined;\n    const iriTagNames = new Set();\n    const iriProperties = [];\n    let changed = false;\n    let i, j;\n    if (idElements.length) {\n        // Make all IDs unique by adding the ID suffix and collect all encountered tag names\n        // that are IRI referenceable from properities.\n        for (i = 0; i < idElements.length; i++) {\n            const tagName = idElements[i].localName; // Use non-namespaced tag name\n            // Make ID unique if tag name is IRI referenceable\n            if (isKeyOf(tagName, IRI_TAG_PROPERTIES_MAP)) {\n                iriTagNames.add(tagName);\n            }\n        }\n        // Get all properties that are mapped to the found IRI referenceable tags\n        iriTagNames.forEach((tagName) => {\n            (IRI_TAG_PROPERTIES_MAP[tagName] || [tagName]).forEach(function (mappedProperty) {\n                // Add mapped properties to array of iri referencing properties.\n                // Use linear search here because the number of possible entries is very small (maximum 11)\n                if (iriProperties.indexOf(mappedProperty) < 0) {\n                    iriProperties.push(mappedProperty);\n                }\n            });\n        });\n        if (iriProperties.length) {\n            // Add \"style\" to properties, because it may contain references in the form 'style=\"fill:url(#myFill)\"'\n            iriProperties.push(\"style\");\n        }\n        // Run through all elements of the SVG and replace IDs in references.\n        // To get all descending elements, getElementsByTagName('*') seems to perform faster than querySelectorAll('*').\n        // Since svgElem.getElementsByTagName('*') getElementsByTagName not return the svg element itself, we have to handle it separately.\n        const descElements = svgElem.getElementsByTagName(\"*\");\n        let element = svgElem;\n        let propertyName;\n        let value;\n        let newValue;\n        for (i = -1; element !== null;) {\n            if (element.localName === \"style\") {\n                // If element is a style element, replace IDs in all occurences of \"url(#anyId)\" in text content\n                value = element.textContent;\n                newValue =\n                    value &&\n                        value.replace(funcIriRegex, function (_, id) {\n                            if (referencedIds) {\n                                referencedIds.add(id);\n                            }\n                            return \"url(#\" + id + idSuffix + \")\";\n                        });\n                if (newValue !== value) {\n                    element.textContent = newValue;\n                }\n            }\n            else if (element.hasAttributes()) {\n                // Run through all property names for which IDs were found\n                for (j = 0; j < iriProperties.length; j++) {\n                    propertyName = iriProperties[j];\n                    value = element.getAttribute(propertyName);\n                    newValue =\n                        value &&\n                            value.replace(funcIriRegex, function (_, id) {\n                                if (referencedIds) {\n                                    referencedIds.add(id);\n                                }\n                                return \"url(#\" + id + idSuffix + \")\";\n                            });\n                    if (newValue && newValue !== value) {\n                        element.setAttribute(propertyName, newValue);\n                    }\n                }\n                // Replace IDs in xlink:ref and href attributes\n                for (const refAttrName of [\"xlink:href\", \"href\"]) {\n                    let iri = element.getAttribute(refAttrName);\n                    if (iri && /^\\s*#/.test(iri)) {\n                        // Check if iri is non-null and internal reference\n                        iri = iri.trim();\n                        element.setAttribute(refAttrName, iri + idSuffix);\n                        if (referencedIds) {\n                            // Add ID to referenced IDs\n                            referencedIds.add(iri.substring(1));\n                        }\n                    }\n                }\n            }\n            element = descElements.item(++i);\n        }\n        for (i = 0; i < idElements.length; i++) {\n            idElem = idElements[i];\n            // If set of referenced IDs exists, make only referenced IDs unique,\n            // otherwise make all IDs unique.\n            if (!referencedIds || referencedIds.has(idElem.id)) {\n                // Add suffix to element's ID\n                idElem.id += idSuffix;\n                changed = true;\n            }\n        }\n    }\n    // return true if SVG element has changed\n    return changed;\n};\n//# sourceMappingURL=util.js.map","import { attrAutoFillSvg, attrRotation, attrTitle, attrTransformCoords, attrWH, } from \"./AttrHelper.js\";\nimport * as notFound from \"./not_found.js\";\nimport { makeIdsUnique } from \"./util.js\";\nconst RenderImage = async (shape, { canvasSize, pathResolver }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    const path = shape.href.contents;\n    let rawSVG = await pathResolver(path);\n    if (rawSVG === undefined) {\n        console.error(`Could not resolve image path ${path}`);\n        rawSVG = notFound.image;\n    }\n    attrToNotAutoMap.push(\"href\");\n    elem.innerHTML = rawSVG;\n    // We assume the first svg element in the file is the one to display\n    const svg = elem.querySelector(\"svg\");\n    // make sure the SVG has unique IDs so multiple diagrams can appear on the screen\n    makeIdsUnique(elem, false);\n    attrToNotAutoMap.push(...attrWH(shape, svg));\n    attrToNotAutoMap.push(...attrRotation(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrTransformCoords(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    svg.setAttribute(\"preserveAspectRatio\", shape.preserveAspectRatio.contents);\n    attrToNotAutoMap.push(\"preserveAspectRatio\");\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderImage;\n//# sourceMappingURL=Image.js.map","import { getArrowhead, round2, toScreen, toSvgOpacityProperty, toSvgPaintProperty, } from \"../utils/Util.js\";\nimport { attrAutoFillSvg, attrStroke, attrTitle } from \"./AttrHelper.js\";\nexport const arrowHead = (id, color, opacity, arrow, size, flip) => {\n    const marker = document.createElementNS(\"http://www.w3.org/2000/svg\", \"marker\");\n    marker.setAttribute(\"id\", id);\n    marker.setAttribute(\"markerUnits\", \"strokeWidth\");\n    marker.setAttribute(\"markerWidth\", round2(arrow.width * size).toString());\n    marker.setAttribute(\"markerHeight\", round2(arrow.height * size).toString());\n    marker.setAttribute(\"viewBox\", arrow.viewbox);\n    marker.setAttribute(\"refX\", arrow.refX.toString());\n    marker.setAttribute(\"refY\", arrow.refY.toString());\n    if (flip) {\n        marker.setAttribute(\"orient\", \"auto\");\n    }\n    else {\n        marker.setAttribute(\"orient\", \"auto-start-reverse\");\n    }\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    path.setAttribute(\"d\", arrow.path);\n    if (arrow.fillKind === \"stroke\") {\n        path.setAttribute(\"fill\", \"none\");\n        marker.setAttribute(\"stroke\", color);\n        marker.setAttribute(\"stroke-opacity\", opacity.toString());\n    } /* if (arrow.fillKind === \"fill\") */\n    else {\n        path.setAttribute(\"fill\", color);\n        path.setAttribute(\"fill-opacity\", opacity.toString());\n    }\n    if (arrow.style) {\n        Object.entries(arrow.style).forEach(([key, value]) => {\n            path.setAttribute(key, value);\n        });\n    }\n    marker.appendChild(path);\n    return marker;\n};\nconst makeRoomForArrows = (shape, startArrowhead, endArrowhead) => {\n    // Keep a list of which input properties we programatically mapped\n    const attrMapped = [];\n    const [lineSX, lineSY] = [shape.start.contents[0], shape.start.contents[1]];\n    const [lineEX, lineEY] = [shape.end.contents[0], shape.end.contents[1]];\n    const startArrowheadSize = shape.startArrowheadSize.contents;\n    const endArrowheadSize = shape.endArrowheadSize.contents;\n    const thickness = shape.strokeWidth.contents;\n    attrMapped.push(\"start\", \"end\", \"startArrowhead\", \"endArrowhead\", \"startArrowheadSize\", \"endArrowheadSize\", \"strokeWidth\");\n    // height * size = Penrose computed arrow size\n    // multiplied by thickness since the arrow size uses markerUnits, which is strokeWidth by default:\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/markerUnits\n    const length = Math.sqrt((lineSX - lineEX) ** 2 + (lineSY - lineEY) ** 2);\n    // zero length arrow doesn't need to be moved. Render as just the arrowhead by default\n    if (length === 0) {\n        return [\n            [\n                [lineSX, lineSY],\n                [lineEX, lineEY],\n            ],\n            attrMapped,\n        ];\n    }\n    // Subtract off the arrowHeight from each side.\n    // See https://math.stackexchange.com/a/2045181 for a derivation.\n    let arrowSX, arrowSY;\n    if (startArrowhead) {\n        const startFlip = shape.flipStartArrowhead.contents;\n        const startArrowWidth = (startFlip\n            ? startArrowhead.refX\n            : startArrowhead.width - startArrowhead.refX) *\n            startArrowheadSize *\n            thickness;\n        const dx = (startArrowWidth / length) * (lineSX - lineEX);\n        const dy = (startArrowWidth / length) * (lineSY - lineEY);\n        [arrowSX, arrowSY] = [lineSX - dx, lineSY - dy];\n    }\n    else {\n        [arrowSX, arrowSY] = [lineSX, lineSY];\n    }\n    let arrowEX, arrowEY;\n    if (endArrowhead) {\n        const endArrowWidth = (endArrowhead.width - endArrowhead.refX) * endArrowheadSize * thickness;\n        [arrowEX, arrowEY] = [\n            lineEX - (endArrowWidth / length) * (lineEX - lineSX),\n            lineEY - (endArrowWidth / length) * (lineEY - lineSY),\n        ];\n    }\n    else {\n        [arrowEX, arrowEY] = [lineEX, lineEY];\n    }\n    return [\n        [\n            [arrowSX, arrowSY],\n            [arrowEX, arrowEY],\n        ],\n        attrMapped,\n    ];\n};\nconst RenderLine = (shape, { canvasSize, namespace, variation }) => {\n    const startArrowhead = getArrowhead(shape.startArrowhead.contents);\n    const endArrowhead = getArrowhead(shape.endArrowhead.contents);\n    const [[[arrowSX, arrowSY], [arrowEX, arrowEY]], attrToNotAutoMap] = makeRoomForArrows(shape, startArrowhead, endArrowhead);\n    const color = toSvgPaintProperty(shape.strokeColor.contents);\n    const opacity = toSvgOpacityProperty(shape.strokeColor.contents);\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    // set line start and end\n    const [sx, sy] = toScreen([arrowSX, arrowSY], canvasSize);\n    const [ex, ey] = toScreen([arrowEX, arrowEY], canvasSize);\n    line.setAttribute(\"x1\", sx.toString());\n    line.setAttribute(\"y1\", sy.toString());\n    line.setAttribute(\"x2\", ex.toString());\n    line.setAttribute(\"y2\", ey.toString());\n    // an unique id for this instance is determined by the variation and namespace\n    const unique = `${namespace}-${variation}-${shape.name.contents}`;\n    const startArrowId = unique + \"-startArrowId\";\n    const endArrowId = unique + \"-endArrowId\";\n    if (startArrowhead) {\n        const startArrowheadSize = shape.startArrowheadSize.contents;\n        const flip = shape.flipStartArrowhead.contents;\n        elem.appendChild(arrowHead(startArrowId, color, opacity, startArrowhead, startArrowheadSize, flip));\n    }\n    if (endArrowhead) {\n        const endArrowheadSize = shape.endArrowheadSize.contents;\n        elem.appendChild(arrowHead(endArrowId, color, opacity, endArrowhead, endArrowheadSize, false));\n    }\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(\"startArrowhead\", \"flipStartArrowhead\", \"endArrowhead\", \"startArrowheadSize\", \"endArrowheadSize\");\n    attrToNotAutoMap.push(...attrStroke(shape, line));\n    // TODO: dedup in AttrHelper\n    if (startArrowhead) {\n        line.setAttribute(\"marker-start\", `url(#${startArrowId})`);\n        attrToNotAutoMap.push(\"startArrowhead\");\n    }\n    if (endArrowhead) {\n        line.setAttribute(\"marker-end\", `url(#${endArrowId})`);\n        attrToNotAutoMap.push(\"endArrowhead\");\n    }\n    elem.appendChild(line);\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderLine;\n//# sourceMappingURL=Line.js.map","import _ from \"lodash\";\nimport { getArrowhead, toScreen, toSvgOpacityProperty, toSvgPaintProperty, } from \"../utils/Util.js\";\nimport { attrAutoFillSvg, attrFill, attrStroke, attrTitle, } from \"./AttrHelper.js\";\nimport { arrowHead } from \"./Line.js\";\nconst toPathString = (pathData, canvasSize) => pathData\n    .map((pathCmd) => {\n    const { cmd, contents } = pathCmd;\n    if (contents.length === 0 && cmd !== \"Z\") {\n        console.error(\"WARNING: empty path\");\n        return \"\";\n    }\n    const pathStr = _.flatten(\n    // the `number[]` type annotation is necessary to ensure that a compile\n    // error occurs here if more `SubPath` subtypes are added in the future\n    contents.map((c) => {\n        switch (c.tag) {\n            case \"CoordV\": {\n                return toScreen([c.contents[0], c.contents[1]], canvasSize);\n            }\n            case \"ValueV\": {\n                return c.contents;\n            }\n        }\n    })).join(\" \");\n    return `${cmd} ${pathStr}`;\n})\n    .join(\" \");\nconst Shadow = (id) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"filter\");\n    elem.setAttribute(\"id\", id);\n    elem.setAttribute(\"x\", \"0\");\n    elem.setAttribute(\"y\", \"0\");\n    elem.setAttribute(\"width\", \"200%\");\n    elem.setAttribute(\"height\", \"200%\");\n    elem.innerHTML = `\n    <feOffset result=\"offOut\" in=\"SourceAlpha\" dx=\"5\" dy=\"5\" />\n       <feGaussianBlur result=\"blurOut\" in=\"offOut\" stdDeviation=\"4\" />\n       <feBlend in=\"SourceGraphic\" in2=\"blurOut\" mode=\"normal\" />\n       <feComponentTransfer>\n         <feFuncA type=\"linear\" slope=\"0.5\" />\n       </feComponentTransfer>\n       <feMerge>\n         <feMergeNode />\n         <feMergeNode in=\"SourceGraphic\" />\n       </feMerge>\n    `;\n    return elem;\n};\nexport const RenderPath = (shape, { canvasSize }) => {\n    // TODO: distinguish between fill opacity and stroke opacity\n    const startArrowId = shape.name.contents + \"-startArrowId\";\n    const endArrowId = shape.name.contents + \"-endArrowId\";\n    const shadowId = shape.name.contents + \"-shadow\";\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    const strokeColor = toSvgPaintProperty(shape.strokeColor.contents);\n    const strokeOpacity = toSvgOpacityProperty(shape.strokeColor.contents);\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    const startArrowhead = getArrowhead(shape.startArrowhead.contents);\n    const endArrowhead = getArrowhead(shape.endArrowhead.contents);\n    if (startArrowhead) {\n        const startArrowId = shape.name.contents + \"-startArrowId\";\n        const startArrowheadSize = shape.startArrowheadSize.contents;\n        const flip = shape.flipStartArrowhead.contents;\n        elem.appendChild(arrowHead(startArrowId, strokeColor, strokeOpacity, startArrowhead, startArrowheadSize, flip));\n    }\n    if (endArrowhead) {\n        const endArrowId = shape.name.contents + \"-endArrowId\";\n        const endArrowheadSize = shape.endArrowheadSize.contents;\n        elem.appendChild(arrowHead(endArrowId, strokeColor, strokeOpacity, endArrowhead, endArrowheadSize, false));\n    }\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(\"name\", \"startArrowhead\", \"flipStartArrowhead\", \"endArrowhead\");\n    elem.appendChild(Shadow(shadowId));\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    attrToNotAutoMap.push(...attrFill(shape, path));\n    attrToNotAutoMap.push(...attrStroke(shape, path));\n    path.setAttribute(\"d\", toPathString(shape.d.contents, canvasSize));\n    attrToNotAutoMap.push(\"d\");\n    if (startArrowhead) {\n        path.setAttribute(\"marker-start\", `url(#${startArrowId})`);\n        attrToNotAutoMap.push(\"startArrowhead\");\n    }\n    if (endArrowhead) {\n        path.setAttribute(\"marker-end\", `url(#${endArrowId})`);\n        attrToNotAutoMap.push(\"endArrowhead\");\n    }\n    elem.appendChild(path);\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderPath;\n//# sourceMappingURL=Path.js.map","import { attrAutoFillSvg, attrFill, attrPolyPoints, attrScale, attrStroke, attrTitle, } from \"./AttrHelper.js\";\nconst RenderPolygon = (shape, { canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    attrToNotAutoMap.push(...attrScale(shape, elem));\n    attrToNotAutoMap.push(...attrPolyPoints(shape, canvasSize, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderPolygon;\n//# sourceMappingURL=Polygon.js.map","import { attrAutoFillSvg, attrFill, attrPolyPoints, attrScale, attrStroke, attrTitle, } from \"./AttrHelper.js\";\nconst RenderPolyline = (shape, { canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polyline\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    attrToNotAutoMap.push(...attrScale(shape, elem));\n    attrToNotAutoMap.push(...attrPolyPoints(shape, canvasSize, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderPolyline;\n//# sourceMappingURL=Polyline.js.map","import { attrAutoFillSvg, attrCornerRadius, attrFill, attrRotation, attrStroke, attrTitle, attrWH, attrXY, } from \"./AttrHelper.js\";\nconst RenderRectangle = (shape, { canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrXY(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrWH(shape, elem));\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    attrToNotAutoMap.push(...attrCornerRadius(shape, elem));\n    attrToNotAutoMap.push(...attrRotation(shape, canvasSize, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderRectangle;\n//# sourceMappingURL=Rectangle.js.map","import { toScreen } from \"../utils/Util.js\";\nimport { attrAutoFillSvg, attrFill, attrFont, attrRotation, attrString, attrStroke, attrTitle, attrWH, } from \"./AttrHelper.js\";\nconst RenderText = (shape, { canvasSize, labels }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(\"x\", \"y\");\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    attrToNotAutoMap.push(...attrString(shape, elem));\n    attrToNotAutoMap.push(...attrRotation(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrFont(shape, elem));\n    // Get width/height of the text if available\n    const name = shape.name;\n    const retrievedLabel = labels.get(name.contents);\n    // Directly render the text with [x, y] in screen coordinates without transforming them using `width` and `height`\n    const center = shape.center;\n    const [x, y] = toScreen([center.contents[0], center.contents[1]], canvasSize);\n    if (retrievedLabel && retrievedLabel.tag === \"TextData\") {\n        // adjust the y-coordinate of the text center s.t. it's the center of the bbox\n        // see https://user-images.githubusercontent.com/11740102/149545843-84406be2-b3dc-4294-b01f-26ef8a2098ee.png for an illustration\n        const descent = retrievedLabel.descent.contents;\n        const height = retrievedLabel.height.contents;\n        const centerY = y + (height / 2 - descent);\n        elem.setAttribute(\"x\", x.toString());\n        elem.setAttribute(\"y\", centerY.toString());\n        attrToNotAutoMap.push(...attrWH(shape, elem));\n    }\n    else {\n        elem.setAttribute(\"x\", x.toString());\n        elem.setAttribute(\"y\", y.toString());\n    }\n    elem.setAttribute(\"font-size-adjust\", shape.fontSizeAdjust.contents);\n    elem.setAttribute(\"alignment-baseline\", shape.alignmentBaseline.contents);\n    elem.setAttribute(\"dominant-baseline\", shape.dominantBaseline.contents);\n    elem.setAttribute(\"ascent\", shape.ascent.contents.toString());\n    elem.setAttribute(\"descent\", shape.descent.contents.toString());\n    elem.setAttribute(\"text-anchor\", shape.textAnchor.contents.toString());\n    elem.setAttribute(\"visibility\", shape.visibility.contents);\n    attrToNotAutoMap.push(\"fontSizeAdjust\", \"alignmentBaseline\", \"dominantBaseline\", \"ascent\", \"descent\", \"textAnchor\", \"visibility\");\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderText;\n//# sourceMappingURL=Text.js.map","import { start } from \"../engine/Optimizer.js\";\n/**\n * Retrieve data from drag events and update varying state accordingly\n */\nexport const dragUpdate = (state, id, dx, dy) => {\n    const xs = [...state.varyingValues];\n    // TODO: fix dragging\n    const updated = {\n        ...state,\n        params: start(xs.length),\n        varyingValues: xs,\n    };\n    return updated;\n};\n//# sourceMappingURL=dragUtils.js.map","/* Renderer.ts\n *\n * A simple translation layer for turning Shapes into SVG tags.\n *\n */\nimport { compile } from \"../engine/Autodiff.js\";\nimport { maxN, minN } from \"../engine/AutodiffFunctions.js\";\nimport { maxX, maxY, minX, minY } from \"../engine/BBox.js\";\nimport { bboxFromShape } from \"../lib/Queries.js\";\nimport { isLinelike, isRectlike } from \"../lib/Utils.js\";\nimport { toScreen } from \"../utils/Util.js\";\nimport { attrAutoFillSvg, attrTitle } from \"./AttrHelper.js\";\nimport RenderCircle from \"./Circle.js\";\nimport RenderEllipse from \"./Ellipse.js\";\nimport RenderEquation from \"./Equation.js\";\nimport RenderImage from \"./Image.js\";\nimport RenderLine from \"./Line.js\";\nimport RenderPath from \"./Path.js\";\nimport RenderPolygon from \"./Polygon.js\";\nimport RenderPolyline from \"./Polyline.js\";\nimport RenderRectangle from \"./Rectangle.js\";\nimport RenderText from \"./Text.js\";\nimport { dragUpdate } from \"./dragUtils.js\";\n/**\n * Converts screen to relative SVG coords\n * Thanks to\n * https://www.petercollingridge.co.uk/tutorials/svg/interactive/dragging/\n * @param e\n * @param svg\n */\nconst getPosition = ({ clientX, clientY }, svg) => {\n    const CTM = svg.getScreenCTM();\n    if (CTM !== null) {\n        return { x: (clientX - CTM.e) / CTM.a, y: (clientY - CTM.f) / CTM.d };\n    }\n    return { x: 0, y: 0 };\n};\n/**\n *\n * @param state\n * @param updateState Callback for drag-updated state\n * @param pathResolver Resolves paths to static strings\n * @returns\n */\nexport const toInteractiveSVG = async (state, updateState, pathResolver, namespace) => {\n    const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n    svg.setAttribute(\"version\", \"1.2\");\n    svg.setAttribute(\"viewBox\", `0 0 ${state.canvas.width} ${state.canvas.height}`);\n    const onDrag = (id, dx, dy) => {\n        updateState(dragUpdate(state, id, dx, dy));\n    };\n    const shapes = state.computeShapes(state.varyingValues);\n    await RenderShapes(shapes, svg, {\n        labels: state.labelCache,\n        canvasSize: state.canvas.size,\n        variation: state.variation,\n        namespace,\n        texLabels: false,\n        pathResolver,\n    }, {\n        updateState,\n        onDrag,\n        parentSVG: svg,\n    });\n    return svg;\n};\n/**\n * Renders a static SVG of the shapes and labels.\n * @param pathResolver Resolves paths to static strings\n */\nexport const toSVG = async ({ varyingValues, canvas, computeShapes, labelCache: labels, variation, }, pathResolver, namespace, texLabels = false) => {\n    const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    svg.setAttribute(\"version\", \"1.2\");\n    svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n    svg.setAttribute(\"viewBox\", `0 0 ${canvas.width} ${canvas.height}`);\n    const shapes = computeShapes(varyingValues);\n    // Find x and y ranges of shapes by using their bounding boxes\n    const bboxs = shapes.map((shape) => bboxFromShape(shape));\n    const MinX = minN(bboxs.map((bbox) => minX(bbox)));\n    const MinY = minN(bboxs.map((bbox) => minY(bbox)));\n    const MaxX = maxN(bboxs.map((bbox) => maxX(bbox)));\n    const MaxY = maxN(bboxs.map((bbox) => maxY(bbox)));\n    const viewBoxRanges = [MinX, MinY, MaxX, MaxY];\n    const [mx, my, Mx, My] = (await compile(viewBoxRanges))((x) => x.val);\n    // toScreen flips the y-axis and therefore the max will become min\n    const [mxt, myt] = toScreen([mx, my], [canvas.width, canvas.height]);\n    const [Mxt, Myt] = toScreen([Mx, My], [canvas.width, canvas.height]);\n    // New top left point and canvas size for cropped view box\n    const topLeft = [mxt, Myt];\n    const croppedCanvasSize = [Mxt - mxt, myt - Myt];\n    // Add cropped view box metadata to svg\n    svg.setAttribute(\"penrose\", \"0\");\n    const metadata = document.createElementNS(\"https://penrose.cs.cmu.edu/metadata\", \"penrose\");\n    const croppedViewBox = document.createElementNS(\"https://penrose.cs.cmu.edu/croppedViewBox\", \"croppedViewBox\");\n    croppedViewBox.insertAdjacentText(\"afterbegin\", `${topLeft[0]} ${topLeft[1]} ${croppedCanvasSize[0]} ${croppedCanvasSize[1]}`);\n    metadata.appendChild(croppedViewBox);\n    svg.appendChild(metadata);\n    await RenderShapes(shapes, svg, {\n        labels,\n        canvasSize: canvas.size,\n        variation,\n        namespace,\n        texLabels,\n        pathResolver,\n    }, undefined);\n    return svg;\n};\nconst RenderGroup = async (groupShape, shapeProps, interactiveProp) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    const clip = groupShape.clipPath.contents;\n    let clipShapeName = undefined;\n    let clipPathSvgId = undefined;\n    if (clip.tag === \"Clip\") {\n        const clipShape = clip.contents;\n        clipShapeName = clipShape.name.contents;\n        const clipShapeSvg = await RenderShape(clipShape, shapeProps, interactiveProp);\n        const clipPathSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"clipPath\");\n        // use the renderer namespace to make sure the clip path id is unique\n        clipPathSvgId = shapeProps.namespace + clipShapeName + \"-clip\";\n        clipPathSvg.setAttribute(\"id\", clipPathSvgId);\n        clipPathSvg.appendChild(clipShapeSvg);\n        elem.appendChild(clipPathSvg);\n    }\n    const subShapes = groupShape.shapes.contents;\n    for (const shape of subShapes) {\n        const name = shape.name.contents;\n        if (clip.tag === \"Clip\") {\n            if (name !== clipShapeName) {\n                const childSvg = await RenderShape(shape, shapeProps, interactiveProp);\n                // wraps the shape in a <g> tag so that clipping is applied after all the transformations etc.\n                const wrapper = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n                wrapper.appendChild(childSvg);\n                wrapper.setAttribute(\"clip-path\", `url(#${clipPathSvgId})`);\n                elem.appendChild(wrapper);\n            }\n            // If already rendered as clip shape, don't render it here because the clip shape is implicitly a group member.\n        }\n        else {\n            const childSvg = await RenderShape(shape, shapeProps, interactiveProp);\n            elem.appendChild(childSvg);\n        }\n    }\n    attrAutoFillSvg(groupShape, elem, [\n        ...attrTitle(groupShape, elem),\n        \"shapes\",\n        \"clipPath\",\n    ]);\n    return elem;\n};\nconst RenderShapeSvg = async (shape, renderProps) => {\n    switch (shape.shapeType) {\n        case \"Circle\":\n            return RenderCircle(shape, renderProps);\n        case \"Ellipse\":\n            return RenderEllipse(shape, renderProps);\n        case \"Equation\":\n            return RenderEquation(shape, renderProps);\n        case \"Image\":\n            return RenderImage(shape, renderProps);\n        case \"Line\":\n            return RenderLine(shape, renderProps);\n        case \"Path\":\n            return RenderPath(shape, renderProps);\n        case \"Polygon\":\n            return RenderPolygon(shape, renderProps);\n        case \"Polyline\":\n            return RenderPolyline(shape, renderProps);\n        case \"Rectangle\":\n            return RenderRectangle(shape, renderProps);\n        case \"Text\":\n            return RenderText(shape, renderProps);\n    }\n};\nexport const RenderShape = async (shape, renderProps, interactiveProp) => {\n    if (shape.shapeType === \"Group\") {\n        const outSvg = await RenderGroup(shape, renderProps, interactiveProp);\n        return outSvg;\n    }\n    else {\n        const elem = await RenderShapeSvg(shape, renderProps);\n        if (!interactiveProp) {\n            return elem;\n        }\n        else {\n            const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n            if (isLinelike(shape)) {\n                g.setAttribute(\"pointer-events\", \"visibleStroke\");\n            }\n            else if (isRectlike(shape)) {\n                g.setAttribute(\"pointer-events\", \"bounding-box\");\n            }\n            else {\n                g.setAttribute(\"pointer-events\", \"auto\");\n            }\n            g.appendChild(elem);\n            const onMouseDown = (e) => {\n                const { clientX, clientY } = e;\n                const { x: tempX, y: tempY } = getPosition({ clientX, clientY }, interactiveProp.parentSVG);\n                const { width: bboxW, height: bboxH, x: bboxX, y: bboxY, } = e.target.getBBox({ stroke: true });\n                const minX = tempX - bboxX;\n                const maxX = renderProps.canvasSize[0] - bboxW + (tempX - bboxX);\n                const minY = tempY - bboxY;\n                const maxY = renderProps.canvasSize[1] - bboxH + (tempY - bboxY);\n                g.setAttribute(\"opacity\", \"0.5\");\n                let dx = 0, dy = 0;\n                const onMouseMove = (e) => {\n                    const { x, y } = getPosition(e, interactiveProp.parentSVG);\n                    const constrainedX = clamp(x, minX, maxX);\n                    const constrainedY = clamp(y, minY, maxY);\n                    dx = constrainedX - tempX;\n                    dy = tempY - constrainedY;\n                    g.setAttribute(`transform`, `translate(${dx},${-dy})`);\n                };\n                const onMouseUp = () => {\n                    g.setAttribute(\"opacity\", \"1\");\n                    document.removeEventListener(\"mouseup\", onMouseUp);\n                    document.removeEventListener(\"mousemove\", onMouseMove);\n                    interactiveProp.onDrag(shape.name.contents, dx, dy);\n                };\n                document.addEventListener(\"mouseup\", onMouseUp);\n                document.addEventListener(\"mousemove\", onMouseMove);\n            };\n            g.addEventListener(\"mousedown\", onMouseDown);\n            return g;\n        }\n    }\n};\nexport const RenderShapes = async (shapes, svg, renderProps, interactiveProp) => {\n    for (const shape of shapes) {\n        const elem = await RenderShape(shape, renderProps, interactiveProp);\n        svg.appendChild(elem);\n    }\n};\nconst clamp = (x, min, max) => Math.min(Math.max(x, min), max);\n//# sourceMappingURL=Renderer.js.map","import seedrandom from \"seedrandom\";\nimport { compileDomain } from \"./compiler/Domain.js\";\nimport { compileStyle } from \"./compiler/Style.js\";\nimport { compileSubstance } from \"./compiler/Substance.js\";\nimport { start, stepUntil } from \"./engine/Optimizer.js\";\nimport { toInteractiveSVG, toSVG } from \"./renderer/Renderer.js\";\nimport { collectLabels, insertLabelMeasurements, mathjaxInit, } from \"./utils/CollectLabels.js\";\nimport { andThen, err, nanError, ok, showError, } from \"./utils/Error.js\";\nimport { unwrap } from \"./utils/Util.js\";\n/**\n * Use the current resample seed to sample all shapes in the State.\n * @param state current state\n */\nexport const resample = (state) => {\n    const rng = seedrandom(state.variation);\n    return insertLabelMeasurements({\n        ...state,\n        // resample all sampled inputs\n        varyingValues: state.inputs.map(({ meta }) => meta.init.tag === \"Sampled\" ? meta.init.sampler(rng) : meta.init.pending),\n        // restart from the first stage\n        currentStageIndex: 0,\n        params: start(state.varyingValues.length),\n    });\n};\n/**\n * Take steps in the optimizer until either `until` evaluates to `true`, or the optimizer reaches convergence.\n * @param state current state\n * @param options `until` is a function that returns the early-stop condition.\n */\nexport const step = (state, options) => {\n    const { constraintSets, optStages, currentStageIndex } = state;\n    const stage = optStages[currentStageIndex];\n    const masks = unwrap(constraintSets.get(stage), () => `missing stage: ${stage}`);\n    const xs = new Float64Array(state.varyingValues);\n    const params = stepUntil((x, weight, grad) => state.gradient(masks, x, weight, grad).phi, xs, state.params, options.until);\n    // if there is an optimizer error, wrap it around a `PenroseError`\n    if (params.optStatus === \"Error\") {\n        return err({\n            errorType: \"RuntimeError\",\n            ...nanError(\"\", state),\n        });\n    }\n    else {\n        return ok({ ...state, varyingValues: Array.from(xs), params });\n    }\n};\n/**\n * Take n steps in the optimizer given the current state.\n * @param state current state\n * @param numSteps number of steps to take (default: 10000)\n */\nexport const stepTimes = (state, numSteps = 10000) => {\n    let i = 0;\n    const steppedState = step(state, { until: () => i++ >= numSteps });\n    if (steppedState.isErr()) {\n        return steppedState;\n    }\n    else {\n        const state = steppedState.value;\n        if (isOptimized(state) && !finalStage(state)) {\n            const nextInitState = nextStage(state);\n            return ok(nextInitState);\n        }\n        else {\n            return steppedState;\n        }\n    }\n};\n/**\n * Move the current state to the next layout stage. If the current state is already at the final stage, return the current state.\n * @param state current state\n */\nexport const nextStage = (state) => {\n    if (finalStage(state)) {\n        return state;\n    }\n    else {\n        return {\n            ...state,\n            currentStageIndex: state.currentStageIndex + 1,\n            params: start(state.varyingValues.length),\n        };\n    }\n};\n/**\n * Run the optimizer on the current state until the current layout stage converges.\n * @param state current state\n */\nexport const stepNextStage = (state) => {\n    let currentState = state;\n    while (!isOptimized(currentState)) {\n        // step until convergence of the current stage.\n        const res = step(currentState, { until: () => false });\n        if (res.isOk()) {\n            currentState = res.value;\n        }\n        else {\n            return res;\n        }\n    }\n    return ok(nextStage(currentState));\n};\n/**\n * Run the optimizer on the current state until it converges.\n * @param state current state\n */\nexport const optimize = (state) => {\n    let currentState = state;\n    while (!isOptimized(currentState) || !finalStage(currentState)) {\n        if (isOptimized(currentState)) {\n            currentState = nextStage(currentState);\n        }\n        const res = step(currentState, { until: () => false });\n        if (res.isOk()) {\n            currentState = res.value;\n        }\n        else {\n            return res;\n        }\n    }\n    return ok(currentState);\n};\nconst optimizeOrThrow = (state) => {\n    const result = optimize(state);\n    if (result.isErr()) {\n        throw Error(showError(result.error));\n    }\n    else {\n        return result.value;\n    }\n};\n/**\n * Embed a static Penrose diagram in a DOM node.\n *\n * @param prog a Penrose trio and variation\n * @param node a node in the DOM tree\n * @param pathResolver a resolver function for fetching Style imports\n * @param name the name of the diagram\n */\nexport const diagram = async (prog, node, pathResolver, name) => {\n    const res = await compile(prog);\n    if (res.isOk()) {\n        const state = res.value;\n        const optimized = optimizeOrThrow(state);\n        const rendered = await toSVG(optimized, pathResolver, name ?? \"\");\n        node.appendChild(rendered);\n    }\n    else {\n        throw Error(`Error when generating Penrose diagram: ${showError(res.error)}`);\n    }\n};\n/**\n * Embed an interactive Penrose diagram in a DOM node.\n *\n * @param prog a Penrose trio and variation\n * @param pathResolver a resolver function for fetching Style imports\n * @param node a node in the DOM tree\n * @param name the name of the diagram\n */\nexport const interactiveDiagram = async (prog, node, pathResolver, name) => {\n    const updateData = async (state) => {\n        const stepped = optimizeOrThrow(state);\n        const rendering = await toInteractiveSVG(stepped, updateData, pathResolver, name ?? \"\");\n        node.replaceChild(rendering, node.firstChild);\n    };\n    const res = await compile(prog);\n    if (res.isOk()) {\n        const state = res.value;\n        const optimized = optimizeOrThrow(state);\n        const rendering = await toInteractiveSVG(optimized, updateData, pathResolver, name ?? \"\");\n        node.appendChild(rendering);\n    }\n    else {\n        throw Error(`Error when generating Penrose diagram: ${showError(res.error)}`);\n    }\n};\n/**\n * Given a trio of Domain, Substance, and Style programs, compile them into an initial `State`.\n * @param domainProg a Domain program string\n * @param subProg a Substance program string\n * @param styProg a Style program string\n */\nexport const compile = async (prog) => {\n    const domRes = compileDomain(prog.domain);\n    if (domRes.isErr()) {\n        return err(domRes.error);\n    }\n    const subRes = compileSubstance(prog.substance, domRes.value);\n    if (subRes.isErr()) {\n        return err(subRes.error);\n    }\n    const styRes = await compileStyle(prog.variation, prog.style, prog.excludeWarnings ?? [], subRes.value, domRes.value);\n    if (styRes.isErr()) {\n        return styRes;\n    }\n    else {\n        const state = styRes.value;\n        // collect labels and return state\n        const convert = mathjaxInit();\n        const labelCache = await collectLabels(state.shapes, convert);\n        if (labelCache.isErr()) {\n            return err(labelCache.error);\n        }\n        return ok(insertLabelMeasurements({ ...state, labelCache: labelCache.value }));\n    }\n};\nexport const compileTrio = async (prog) => {\n    const domainRes = compileDomain(prog.domain);\n    if (domainRes.isOk()) {\n        const subRes = andThen((env) => compileSubstance(prog.substance, env), domainRes);\n        if (subRes.isOk()) {\n            const styRes = await compileStyle(prog.variation, prog.style, prog.excludeWarnings ?? [], subRes.value, domainRes.value);\n            return styRes;\n        }\n        else {\n            return err(subRes.error);\n        }\n    }\n    else {\n        return err(domainRes.error);\n    }\n};\n/**\n * Returns true if state is optimized\n * @param state current state\n */\nexport const isOptimized = (state) => state.params.optStatus === \"EPConverged\";\n/**\n * Returns true if state results in an error\n * @param state current state\n */\nexport const isError = (state) => state.params.optStatus === \"Error\";\n/**\n * Returns true if the diagram state is on the last layout stage in the layout pipeline\n * @param state current state\n */\nexport const finalStage = (state) => state.currentStageIndex === state.optStages.length - 1;\nconst evalGrad = (s) => {\n    const { constraintSets, optStages, currentStageIndex } = s;\n    const stage = optStages[currentStageIndex];\n    const masks = unwrap(constraintSets.get(stage), () => `missing stage: ${stage}`);\n    const x = new Float64Array(s.varyingValues);\n    // we constructed `x` to throw away, so it's OK to update it in-place with the\n    // gradient after computing the energy\n    return s.gradient(masks, x, s.params.weight, x);\n};\n/**\n * Evaluate the overall energy of a `State`.\n * @param s a state\n * @returns a scalar value of the current energy\n */\nexport const evalEnergy = (s) => evalGrad(s).phi;\n// TODO: maybe don't also compute the gradient, just to throw it away\n/**\n * Evaluate a list of constraints/objectives.\n * @param s a state\n * @returns a list of the energies of the requested functions, evaluated at the `varyingValues` in the `State`\n */\nexport const evalFns = (s) => {\n    // Evaluate the energy of each requested function (of the given type) on the varying values in the state\n    const outputs = evalGrad(s);\n    // TODO: maybe don't also compute the gradient, just to throw it away\n    return { constrEngs: outputs.constraints, objEngs: outputs.objectives };\n};\nexport * from \"./api.js\";\nexport { checkDomain, compileDomain, parseDomain } from \"./compiler/Domain.js\";\nexport { checkSubstance, compileSubstance, parseSubstance, prettyCompiledSubstance, prettySubstance, } from \"./compiler/Substance.js\";\nexport { constrDict } from \"./lib/Constraints.js\";\nexport { compDict } from \"./lib/Functions.js\";\nexport { objDict } from \"./lib/Objectives.js\";\nexport { RenderShapes, toInteractiveSVG, toSVG } from \"./renderer/Renderer.js\";\nexport { makeCanvas, simpleContext } from \"./shapes/Samplers.js\";\nexport { sampleShape, shapeTypes } from \"./shapes/Shapes.js\";\nexport * from \"./types/state.js\";\nexport * as Value from \"./types/value.js\";\nexport { collectLabels, insertLabelMeasurements as insertPending, mathjaxInit, } from \"./utils/CollectLabels.js\";\nexport { errLocs, showError } from \"./utils/Error.js\";\nexport { allWarnings, describeType, hexToRgba, prettyPrintExpr, prettyPrintFn, prettyPrintPath, rgbaToHex, zip2, } from \"./utils/Util.js\";\n//# sourceMappingURL=index.js.map","export default async function fetchResolver(\n  path: string,\n): Promise<string | undefined> {\n  const response = await fetch(path);\n  if (!response.ok) {\n    console.error(`could not fetch ${path}`);\n    return undefined;\n  }\n  return await response.text();\n}\n","import {\n  PathResolver,\n  PenroseError,\n  PenroseState,\n  compile,\n  isOptimized,\n  optimize,\n  resample,\n  showError,\n  stepTimes,\n  toInteractiveSVG,\n  toSVG,\n} from \"@penrose/core\";\nimport React from \"react\";\nimport fetchResolver from \"./fetchPathResolver.js\";\n\nexport interface SimpleProps {\n  domain: string;\n  substance: string;\n  style: string;\n  variation: string;\n  excludeWarnings?: string[];\n  stepSize?: number;\n  interactive?: boolean; // considered true by default\n  animate?: boolean; // considered false by default\n  onFrame?: (frame: PenroseState) => void;\n  imageResolver?: PathResolver;\n  name?: string;\n}\n\nexport interface SimpleState {\n  error?: PenroseError;\n}\n\nclass Simple extends React.Component<SimpleProps, SimpleState> {\n  readonly canvasRef = React.createRef<HTMLDivElement>();\n  penroseState: PenroseState | undefined = undefined;\n  timerID: number | undefined = undefined; // for animation\n\n  constructor(props: SimpleProps) {\n    super(props);\n    this.state = {\n      error: undefined,\n    };\n  }\n\n  compile = async (): Promise<void> => {\n    this.penroseState = undefined;\n    this.setState({ error: undefined });\n    const compilerResult = await compile(this.props);\n    if (compilerResult.isOk()) {\n      this.penroseState = compilerResult.value;\n      this.setState({ error: undefined }); // clear out errors\n    } else {\n      this.setState({ error: compilerResult.error });\n    }\n  };\n\n  converge = async (): Promise<void> => {\n    if (this.penroseState) {\n      const stepped = optimize(this.penroseState);\n      if (stepped.isOk()) {\n        this.penroseState = stepped.value;\n      } else {\n        this.setState({ error: stepped.error });\n      }\n    }\n  };\n\n  tick = () => {\n    if (\n      this.props.animate &&\n      this.penroseState &&\n      !isOptimized(this.penroseState)\n    ) {\n      const state = stepTimes(this.penroseState, this.props.stepSize ?? 1);\n      if (state.isErr()) {\n        this.setState({ error: state.error });\n      } else {\n        this.penroseState = state.value;\n      }\n      this.renderCanvas();\n    }\n  };\n\n  componentDidMount = async () => {\n    await this.compile();\n    if (!this.props.animate) {\n      await this.converge();\n    }\n    this.renderCanvas();\n    this.timerID = window.setInterval(() => this.tick(), 1000 / 60);\n  };\n\n  componentDidUpdate = async (prevProps: SimpleProps) => {\n    // re-compile if the programs change\n    if (\n      this.props.domain !== prevProps.domain ||\n      this.props.substance !== prevProps.substance ||\n      this.props.style !== prevProps.style\n    ) {\n      await this.compile();\n      if (!this.props.animate) {\n        await this.converge();\n      }\n      this.renderCanvas();\n      return;\n    }\n\n    // update the component only if there's no error\n    // in the case of an error, they component should not attempt to re-render\n    if (this.penroseState && !this.state.error) {\n      if (\n        this.props.variation !== prevProps.variation ||\n        this.props.animate !== prevProps.animate\n      ) {\n        this.penroseState.variation = this.props.variation;\n        this.penroseState = resample(this.penroseState);\n        if (!this.props.animate) {\n          await this.converge();\n        }\n        this.renderCanvas();\n        return;\n      } else if (this.props.interactive !== prevProps.interactive) {\n        this.renderCanvas();\n        return;\n      }\n    }\n  };\n\n  componentWillUnmount = () => {\n    clearInterval(this.timerID);\n  };\n\n  renderCanvas = async () => {\n    if (this.canvasRef.current === null) {\n      return <div>rendering...</div>;\n    } else {\n      const node = this.canvasRef.current;\n      if (this.penroseState) {\n        const renderedState: SVGSVGElement = await (this.props.interactive ===\n        false\n          ? toSVG(\n              this.penroseState,\n              this.props.imageResolver ?? fetchResolver,\n              this.props.name ?? \"\",\n            )\n          : toInteractiveSVG(\n              this.penroseState,\n              async (newState: PenroseState) => {\n                this.penroseState = newState;\n                if (!this.props.animate) {\n                  await this.converge();\n                }\n                this.renderCanvas();\n              },\n              this.props.imageResolver ?? fetchResolver,\n              this.props.name ?? \"\",\n            ));\n        renderedState.setAttribute(\"width\", \"100%\");\n        renderedState.setAttribute(\"height\", \"100%\");\n        if (node.firstChild !== null) {\n          node.replaceChild(renderedState, node.firstChild);\n        } else {\n          node.appendChild(renderedState);\n        }\n        // propagate state update\n        if (this.props.onFrame) {\n          this.props.onFrame(this.penroseState);\n        }\n      } else {\n        return <div>rendering...</div>;\n      }\n    }\n  };\n\n  render = () => {\n    const { error } = this.state;\n    return (\n      <>\n        {!error && (\n          <div style={{ width: \"100%\", height: \"100%\" }} ref={this.canvasRef} />\n        )}\n        {error && (\n          <div style={{ padding: \"1em\", height: \"100%\" }}>\n            <div style={{ fontWeight: 700 }}>1 error:</div>\n            <div style={{ fontFamily: \"monospace\" }}>\n              {showError(error)\n                .toString()\n                .split(\"\\n\")\n                .map((line: string, key: number) => (\n                  <p key={`err-ln-${key}`} style={{ margin: 0 }}>\n                    {line}\n                  </p>\n                ))}\n            </div>\n          </div>\n        )}\n      </>\n    );\n  };\n}\n\nexport { Simple };\n"],"names":["mathjaxInit","__name","adaptor","browserAdaptor","RegisterHTMLHandler","tex","TeX","AllPackages","jax","err","svg","SVG","html","mathjax","input","node","ok","error","parseFontSize","fontSize","regex","match","number","unit","toPxFontSize","tex2svg","properties","convert","resolve","contents","getAdValueAsString","output","body","viewBox","viewBoxArr","width","height","exH","parsedFontSize","em_to_px","n","scaledWidth","scaledHeight","scaledDescent","scaledAscent","floatV","textData","descent","ascent","equationData","rendered","toFontRule","fontFamily","fontStretch","fontStyle","fontVariant","fontWeight","lineHeight","fontSpec","collectLabels","allShapes","labels","s","shapeName","label","measure","measureText","subShapes","getValueAsShapeList","subLabels","key","value","text","font","measureTextElement","measureTextContext","measurements","setPendingProperty","xs","inputs","before","after","index","meta","unwrap","insertPendingHelper","shapes","labelCache","labelData","insertLabelMeasurements","state","varyingValues","handle","attrMapSvg","attrAutoFillSvg","shape","elem","attrAlreadyMapped","attrToNeverAutoMap","attrToNotAutoMap","propKey","propVal","isKeyOf","mappedPropKey","style","attrFill","color","alpha","toSvgOpacityProperty","toSvgPaintProperty","attrCenter","canvasSize","center","x","y","toScreen","attrScale","scale","transform","attrTransformCoords","w","h","attrXY","attrRotation","rotation","attrWH","attrCornerRadius","rx","attrString","str","DASH_ARRAY","attrStroke","attrMapped","strokeColor","strokeAlpha","thickness","attrTitle","name","title","attrFont","fontString","existingStyle","attrPolyPoints","pointsTransformed","p","RenderCircle","RenderEllipse","placeholderString","txt","RenderEquation","renderOptions","texLabels","baselineY","retrievedLabel","renderedLabel","image","uniqueIdCounter","makeIdsUnique","svgElem","onlyReferenced","ID_SUFFIX","IRI_TAG_PROPERTIES_MAP","idSuffix","funcIriRegex","idElements","idElem","referencedIds","iriTagNames","iriProperties","changed","i","j","tagName","mappedProperty","descElements","element","propertyName","newValue","_","id","refAttrName","iri","RenderImage","pathResolver","path","rawSVG","notFound.image","arrowHead","opacity","arrow","size","flip","marker","round2","makeRoomForArrows","startArrowhead","endArrowhead","lineSX","lineSY","lineEX","lineEY","startArrowheadSize","endArrowheadSize","length","arrowSX","arrowSY","startArrowWidth","dx","dy","arrowEX","arrowEY","endArrowWidth","RenderLine","namespace","variation","getArrowhead","line","sx","sy","ex","ey","unique","startArrowId","endArrowId","toPathString","pathData","pathCmd","cmd","pathStr","c","Shadow","RenderPath","shadowId","strokeOpacity","RenderPolygon","RenderPolyline","RenderRectangle","RenderText","centerY","dragUpdate","start","getPosition","clientX","clientY","CTM","toInteractiveSVG","updateState","onDrag","RenderShapes","toSVG","canvas","computeShapes","bboxs","bboxFromShape","MinX","minN","bbox","minX","MinY","minY","MaxX","maxN","maxX","MaxY","maxY","viewBoxRanges","mx","my","Mx","My","compile","mxt","myt","Mxt","Myt","topLeft","croppedCanvasSize","metadata","croppedViewBox","RenderGroup","groupShape","shapeProps","interactiveProp","clip","clipShapeName","clipPathSvgId","clipShape","clipShapeSvg","RenderShape","clipPathSvg","childSvg","wrapper","RenderShapeSvg","renderProps","g","isLinelike","isRectlike","onMouseDown","e","tempX","tempY","bboxW","bboxH","bboxX","bboxY","onMouseMove","constrainedX","clamp","constrainedY","onMouseUp","min","max","resample","rng","seedrandom","step","options","constraintSets","optStages","currentStageIndex","stage","masks","params","stepUntil","weight","grad","nanError","stepTimes","numSteps","steppedState","isOptimized","finalStage","nextInitState","nextStage","optimize","currentState","res","prog","domRes","compileDomain","subRes","compileSubstance","styRes","compileStyle","fetchResolver","response","_Simple","React","undefined","props","compilerResult","stepped","prevProps","clearInterval","_jsx","renderedState","newState","_jsxs","_Fragment","canvasRef","showError","Simple"],"mappings":"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"}