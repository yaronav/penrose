{"version":3,"file":"StagedDiagram.stories-11d058c5.js","sources":["../../../examples/dist/exterior-algebra/vector-wedge.trio.js","../../../examples/dist/geometry-domain/textbook_problems/c05p13.substance.js","../../../examples/dist/geometry-domain/euclidean.style.js","../../../examples/dist/geometry-domain/textbook_problems/c05p13.style.js","../../../examples/dist/geometry-domain/geometry.domain.js","../../../examples/dist/geometry-domain/textbook_problems/c05p13.trio.js","../../../examples/dist/walk-on-spheres/Laplace.substance.js","../../../examples/dist/walk-on-spheres/walk-on-spheres.style.js","../../../examples/dist/walk-on-spheres/walk-on-spheres.domain.js","../../../examples/dist/walk-on-spheres/laplace-estimator.trio.js","../../src/StagedDiagram.tsx"],"sourcesContent":["import substance from \"./vector-wedge.substance.js\";\nimport style0, { resolver as resolver0 } from \"./exterior-algebra.style.js\";\nimport domain from \"./exterior-algebra.domain.js\";\nexport default {\n    substance,\n    style: [\n        { contents: style0, resolver: resolver0 },\n    ],\n    domain,\n    variation: \"SnorlaxIbis743\",\n    excludeWarnings: [\"BBoxApproximationWarning\"]\n};\n//# sourceMappingURL=vector-wedge.trio.js.map","export default \"-- name in registry: incenter-triangle\\nPoint J, K, L, P, m\\nLet JKL := Triangle(J, K, L)\\nIncenter(P, JKL)\\n-- Centroid(P, JKL)\\n-- Circumcenter(P, JKL)\\n-- Orthocenter(P, JKL)\\nLet KL := Segment(K, L)\\nCollinear(K, m, L)\\nLet PLM := Triangle(P, L, m)\\nAngle PML := InteriorAngle(P, m, L)\\nRightMarked(PML)\\nAutoLabel J, K, L, P, m\\n\";\n//# sourceMappingURL=c05p13.substance.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"geometry-domain\");\nexport default \"canvas {\\n  width = 500\\n  height = 500\\n}\\n\\nColors {\\n    -- Keenan palette\\n    black = #000000\\n    darkpurple = #8c90c1\\n    lightpurple = #d0d3e6\\n    purple2 = rgba(0.106, 0.122, 0.54, 0.2)\\n    verylightpurple = rgba(0.953, 0.957, 0.977, 1.0)\\n    purple3 = rgba(0.557, 0.627, 0.769, 1.0)\\n    midnightblue = rgba(0.14, 0.16, 0.52, 1.0)\\n    none = none()\\n}\\n\\nconst {\\n    arrowheadSize = 0.65\\n    strokeWidth = 1.75\\n    textPadding = 10.0\\n    textPadding2 = 25.0\\n    repelWeight = 0.7 -- TODO: Reverted from 0.0\\n    repelWeight2 = 0.5\\n    fontSize = \\\"20px\\\"\\n    containPadding = 50.0\\n    rayLength = 100.0\\n    pointRadius = 4.0\\n    pointStroke = 0.0\\n    thetaRadius = 30.0\\n    circleRadius = 150.0\\n    labelPadding = 30.0\\n    minSegmentLength = 80.0\\n    minLineLength = 200.0\\n}\\n\\nlayout = [shape, label]\\n\\n--Plane\\nforall Plane p {\\n  width = canvas.width * .8\\n  height = canvas.height * .8\\n  p.text = Equation {\\n    center : ((width / 2.0) - const.textPadding2, (height / 2.0) - const.textPadding2)\\n    string : p.label\\n    fontSize : const.fontSize\\n  }\\n\\n  -- inner: #f3f4f9, outer: #8e93c4\\n  p.icon = Rectangle {\\n    -- angle : 0.0\\n    -- fillColor : Colors.purple2\\n    fillColor : Colors.none -- TODO: arrange angle markers so plane can be opaque\\n    strokeColor : Colors.purple3\\n    strokeWidth : 2.0\\n    center : (0.0, 0.0)\\n    width : width\\n    height : height\\n  }\\n\\n  p.text above p.icon\\n}\\n\\n--Point\\nforall Point p {\\n  p.x = ? except label\\n  p.y = ? except label\\n  p.vec = (p.x, p.y)\\n  p.color = Colors.black\\n\\n  p.icon = Circle {\\n    center: p.vec\\n    r : const.pointRadius\\n    fillColor : Colors.black\\n    strokeWidth : 0.0\\n    strokeColor : Colors.black\\n  }\\n\\n  p.text = Equation {\\n    string : p.label\\n    fillColor : Colors.black\\n    fontSize : const.fontSize\\n    center: (? in label, ? in label)\\n    ensureOnCanvas: false\\n  }\\n  ensure onCanvas(p.text, canvas.width, canvas.height) in label\\n  ensure signedDistance(p.text, p.vec) == const.textPadding + const.pointRadius in label\\n}\\n\\n-- default: if `Point` is not on a `Plane`, the point should be below the plane to stay hidden\\nforall Point p\\nwith Plane P {\\n  p.iconOnPlane = ensure disjoint(p.icon, P.icon)\\n  p.textOnPlane = ensure disjoint(p.text, P.icon) in label\\n}\\n\\nforall Point p\\nwith Plane P\\nwhere In(p, P) {\\n  -- TODO: the problem is that this ensures the padding is const? Or is > padding okay?\\n  -- There's a choice of whether to put padding on the point or the text for containment\\n  override p.iconOnPlane = ensure contains(P.icon, p.icon, const.containPadding)\\n  override p.textOnPlane = ensure contains(P.icon, p.text) in label\\n\\n  p.icon above P.icon\\n  p.text above P.icon\\n}\\n\\nforall Point p, q, r\\nwhere Collinear(p, q, r) {\\n  ensure collinearOrdered(p.icon.center, q.icon.center, r.icon.center) \\n  encourage notTooClose(p.icon, r.icon, const.repelWeight)\\n}\\n\\nforall Point p\\nwith Linelike l\\nwhere On(p, l) {\\n  ensure signedDistance(l.icon, p.vec) == 0\\n}\\n\\nforall Point p\\nwith Linelike l\\nwhere On(p, l); p has label {\\n  ensure disjoint(l.icon, p.text) in label\\n}\\n\\n--Linelike\\nforall Linelike l {\\n  l.color = Colors.black\\n\\n  l.icon = Line {\\n    start : (?, ?)\\n    end : (?, ?)\\n    strokeColor : l.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n}\\n\\nforall Ray r\\nwhere r := Ray(base, direction)\\nwith Point base; Point direction {\\n  r.start = base.vec\\n  r.end = direction.vec\\n  r.vec = direction.vec - base.vec\\n\\n  override r.icon = Line {\\n    start : base.icon.center\\n    end : ptOnLine(base.vec, direction.vec, norm(r.vec) + 40.)\\n    strokeColor : r.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n    endArrowhead : \\\"straight\\\"\\n    endArrowheadSize: const.arrowheadSize\\n  }\\n  -- labeling\\n  ensure disjoint(r.icon, base.text) in label\\n  ensure disjoint(r.icon, direction.text) in label\\n}\\n\\nforall Ray r {\\n    r.length = const.rayLength\\n}\\n\\nforall Ray r\\nwith Angle theta; Point x; Point y; Point z\\nwhere r := Bisector(theta); theta := InteriorAngle(y, x, z) {\\n  -- find the vector for the bisector ray\\n  xy = normalize(y.vec - x.vec)\\n  xz = normalize(z.vec - x.vec)\\n  r_vec = xy + xz\\n  -- change from generic `Linelike` shape to a specific shape for `Ray`\\n  override r.icon = Line {\\n    start: x.vec\\n    end:  (r.length * normalize(r_vec)) + x.vec\\n    strokeWidth : const.strokeWidth\\n    strokeColor : Colors.black\\n    endArrowhead: \\\"straight\\\"\\n    endArrowheadSize : const.arrowheadSize\\n  }\\n  r.icon below x.icon\\n}\\n\\nforall Line l\\nwhere l := Line(p, q)\\nwith Point p; Point q {\\n  l.start = p.vec\\n  l.end = q.vec\\n  l.vec = q.vec - p.vec\\n  override l.icon = Line {\\n    start : ptOnLine(p.vec,q.vec, -40.)\\n    end : ptOnLine(p.vec, q.vec, norm(l.vec) + 40.)\\n    strokeColor : l.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n    endArrowhead : \\\"straight\\\"\\n    startArrowhead: \\\"straight\\\"\\n    startArrowheadSize: const.arrowheadSize\\n    endArrowheadSize: const.arrowheadSize\\n  }\\n\\n  -- edge case\\n  ensure norm(l.vec) > const.minLineLength\\n\\n  -- labeling\\n  ensure disjoint(l.icon, p.text) in label\\n  ensure disjoint(l.icon, q.text) in label\\n}\\n\\nforall Linelike l1, l2 -- should this work with rays and lines?\\nwhere ParallelMarker1(l1, l2) {\\n  l1.tick1 = Path {\\n    d : pathFromPoints(\\\"open\\\", chevron(l1.icon, 20.))\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n  l2.tick1 = Path {\\n    d : pathFromPoints(\\\"open\\\", chevron(l2.icon, 20.))\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n}\\n\\nforall Linelike l1, l2\\nwhere Parallel(l1, l2) {\\n  -- the dot product of the unit vectors of parallel lines is 1\\n  -- HACK: scaling to 10000s for convergence\\n  ensure 10000 == dot(normalize(l1.vec), normalize(l2.vec)) * 10000\\n}\\n--Segment\\nforall Segment e\\nwhere e := Segment(p, q)\\nwith Point p; Point q {\\n  e.vec = [q.x - p.x, q.y - p.y]\\n  e.start = p.vec\\n  e.end = q.vec\\n\\n  override e.icon = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeColor : e.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n\\n  p.icon above e.icon\\n  q.icon above e.icon\\n\\n  -- edge case\\n  ensure norm(e.vec) > const.minSegmentLength\\n\\n  -- labeling\\n  ensure disjoint(p.text, e.icon) in label\\n  ensure disjoint(q.text, e.icon) in label\\n}\\n\\nforall Segment e; Plane p {\\n  e.icon above p.icon\\n}\\n\\nforall Linelike s, t\\nwhere EqualLength(s, t) {\\n  ensure vdist(s.icon.start, s.icon.end) == vdist(t.icon.start, t.icon.end)\\n}\\n\\n--TODO eventually this should also provide an equal length marker since it is bisecting the segment\\nforall Segment s\\nwhere s := PerpendicularBisector(s2, p)\\nwith Segment s2; Point p {\\n  override s.icon = Line {\\n    start : p.icon.center\\n    end : midpoint(s2.icon.start, s2.icon.end)\\n    strokeColor : s.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  startA = ptOnLine(s.icon.end, s.icon.start, const.thetaRadius)\\n  endA = ptOnLine(s.icon.end, s2.icon.end, const.thetaRadius)\\n  sweepA = arcSweepFlag(s.icon.end, startA, endA)\\n\\n  s.mark = Path {\\n    d : pathFromPoints(\\\"open\\\", [ptOnLine(s.icon.end, s.icon.start, 20.), innerPointOffset(s.icon.end, s.icon.start, s2.icon.end, 20.), ptOnLine(s.icon.end, s2.icon.end, 20.)])\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n\\n  ensure perpendicular(s.icon.start, s.icon.end, s2.icon.end)\\n}\\n\\nforall Segment s\\nwhere s := PerpendicularBisectorLabelPts(s2, p1, p2)\\nwith Segment s2; Point p1, p2 {\\n  override p2.vec = midpoint(s2.icon.start, s2.icon.end)\\n  override s.icon = Line {\\n    start : p1.icon.center\\n    end : p2.vec\\n    strokeColor : s.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  startA = ptOnLine(s.icon.end, s.icon.start, const.thetaRadius)\\n  endA = ptOnLine(s.icon.end, s2.icon.end, const.thetaRadius)\\n  sweepA = arcSweepFlag(s.icon.end, startA, endA)\\n\\n  s.mark = Path {\\n    d : pathFromPoints(\\\"open\\\", [ptOnLine(s.icon.end, s.icon.start, 20.), innerPointOffset(s.icon.end, s.icon.start, s2.icon.end, 20.), ptOnLine(s.icon.end, s2.icon.end, 20.)])\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n\\n  ensure perpendicular(s.icon.start, s.icon.end, s2.icon.end)\\n}\\n\\nforall Linelike s, t \\nwhere EqualLengthMarker(s, t) as e {\\n  e.equivGroup = match_id\\n  override s.tick = Path {\\n    d : ticksOnLine(s.icon.start, s.icon.end, 15., e.equivGroup, 10.)\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor: Colors.none\\n  }\\n  override t.tick = Path {\\n    d : ticksOnLine(t.icon.start, t.icon.end, 15., e.equivGroup, 10.)\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor: Colors.none\\n  }\\n  s.tick above s.icon\\n  t.tick above t.icon\\n}\\n\\n-- HACK: set transitive equal marks to have the same amount of ticks. This will not decrement subsequent matches of `EqualLength`, so only use this when there are _only_ transitive equal marks in a diagram\\nforall Linelike s, t, u\\nwhere EqualLengthMarker(s, t) as e1; EqualLengthMarker(t, u) as e2 {\\n  minEquivGroup = min(e1.equivGroup, e2.equivGroup)\\n  -- NOTE: since we cannot handle transitive predicates and don't allow recursive expressions, we override the shape properties so the tick counts are the same\\n  override s.tick.d = ticksOnLine(s.icon.start, s.icon.end, 15., minEquivGroup, 10.) \\n  override u.tick.d = ticksOnLine(u.icon.start, u.icon.end, 15., minEquivGroup, 10.) \\n  override t.tick.d = ticksOnLine(t.icon.start, t.icon.end, 15., minEquivGroup, 10.) \\n}\\n\\n--Angle\\nforall Angle theta\\nwhere theta := InteriorAngle(p, q, r)\\nwith Point p; Point q; Point r {\\n  theta.p = p.vec\\n  theta.q = q.vec\\n  theta.r = r.vec\\n  theta.color = #000\\n  theta.side1 = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeColor : theta.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  theta.side2 = Line {\\n    start : q.icon.center\\n    end : r.icon.center\\n    strokeColor : theta.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  \\n  theta.radius = const.thetaRadius\\n  -- encourage the angle to be bigger than 10\\n  angle = angleBetween(theta.q - theta.p, theta.q - theta.r) \\n  ensure angle > 10/180 * MathPI()\\n  theta.side1 below p.icon, q.icon\\n  theta.side2 below q.icon, r.icon\\n}\\n\\nforall Angle theta\\nwhere theta := InteriorAngle(p, q, r); theta has label\\nwith Point p; Point q; Point r {\\n  padding = const.textPadding + const.pointRadius + theta.text.width\\n  labelDir = normalize((p.vec - q.vec) + (r.vec - q.vec))\\n  theta.text = Equation {\\n    string : theta.label\\n    fillColor : Colors.black\\n    fontSize : const.fontSize\\n    center: q.vec + labelDir*padding\\n  }\\n}\\n\\nforall Angle a, b\\nwhere EqualAngleMarker(a, b) as e {\\n  e.equivGroup = match_id\\n  --find points from p->q, then q->r for each vector. draw vectors for each\\n  a.start = ptOnLine(a.q, a.p, a.radius)\\n  a.end = ptOnLine(a.q, a.r, a.radius)\\n  a.sweep = arcSweepFlag(a.q, a.start, a.end)\\n  a.spacing = 10\\n\\n  b.start = ptOnLine(b.q, b.p, b.radius)\\n  b.end = ptOnLine(b.q, b.r, b.radius)\\n  b.sweep = arcSweepFlag(b.q, b.start, b.end)\\n  b.spacing = 10\\n\\n  override a.mark = Path {\\n    d : repeatedArcs(a.start, a.end, a.p, a.r, (a.radius, a.radius), e.equivGroup, a.spacing, a.sweep)\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor: Colors.none\\n }\\n  override b.mark = Path {\\n    d : repeatedArcs(b.start, b.end, b.p, b.r, (b.radius, b.radius), e.equivGroup, b.spacing, b.sweep)\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor: Colors.none\\n }\\n}\\n\\nforall Angle a, b, c\\nwhere EqualAngleMarker(a, b) as e1; EqualAngleMarker(b, c) as e2 {\\n  minEquivGroup = min(e1.equivGroup, e2.equivGroup)\\n  override a.mark.d = repeatedArcs(a.start, a.end, a.p, a.r, (a.radius, a.radius), minEquivGroup, a.spacing, a.sweep)\\n  override b.mark.d = repeatedArcs(b.start, b.end, b.p, b.r, (b.radius, b.radius), minEquivGroup, b.spacing, b.sweep)\\n  override c.mark.d = repeatedArcs(c.start, c.end, c.p, c.r, (c.radius, c.radius), minEquivGroup, c.spacing, c.sweep)\\n}\\n\\nforall Angle a, b\\nwhere EqualAngle(a, b) {\\n  -- make sure angle a is equal to angle b\\n  -- HACK: increase the magnitude of angles\\n  weight = 100\\n  angleA = angleBetween(a.p - a.q, a.r - a.q) * weight\\n  angleB = angleBetween(b.p - b.q, b.r - b.q) * weight\\n  ensure angleA == angleB \\n}\\n\\nforall Angle a\\nwhere RightUnmarked(a) {\\n  -- ensure perpendicular(a.p, a.q, a.r)\\n  vec2 u = a.p - a.q\\n  vec2 v = a.r - a.q\\n  ensure dot(u, v) == 0\\n}\\n\\nforall Angle a\\nwhere RightMarked(a) {\\n  --render half square path of size a.radius\\n  markSize = 10\\n  a.mark = Path {\\n    d : pathFromPoints(\\\"open\\\", [ptOnLine(a.q, a.p, markSize), innerPointOffset(a.q, a.p, a.r, markSize), ptOnLine(a.q, a.r, markSize)])\\n    strokeWidth : 2.0\\n    strokeColor : #000\\n    fillColor : Colors.none\\n  }\\n  vec2 u = a.p - a.q\\n  vec2 v = a.r - a.q\\n  ensure dot(u, v) == 0\\n}\\n\\nforall Angle a\\nwhere Acute(a) {\\n  ensure inRange(angleBetween(a.p - a.q, a.r - a.q), 0, MathPI()/2)\\n}\\n\\nforall Angle a\\nwhere Obtuse(a) {\\n  ensure inRange(angleBetween(a.p - a.q, a.r - a.q), MathPI()/2, MathPI())\\n}\\n\\nforall Triangle t; Plane P \\nwhere t := Triangle(p, q, r)\\nwith Point p; Point q; Point r {\\n  t.PQ above P.icon\\n  t.QR above P.icon\\n  t.RP above P.icon\\n  t.icon above P.icon\\n}\\n\\nforall Triangle t\\nwhere t := Triangle(p, q, r)\\nwith Point p; Point q; Point r {\\n  t.color = Colors.black\\n  t.PQ = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeColor : t.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  t.QR = Line {\\n    start : q.icon.center\\n    end : r.icon.center\\n    strokeColor : t.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  t.RP = Line {\\n    start : r.icon.center\\n    end : p.icon.center\\n    strokeColor : t.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  t.icon = Path {\\n    d: pathFromPoints(\\\"closed\\\", [p.vec, q.vec, r.vec])\\n    fillColor: none()\\n    strokeColor: none()\\n  }\\n  ensure norm(p.vec - q.vec) > const.minSegmentLength\\n  ensure norm(q.vec - r.vec) > const.minSegmentLength\\n  ensure norm(r.vec - p.vec) > const.minSegmentLength\\n  ensure disjoint(t.icon, p.text) in label\\n  ensure disjoint(t.icon, q.text) in label\\n  ensure disjoint(t.icon, r.text) in label\\n\\n  t.PQ below p.icon\\n  t.PQ below q.icon\\n  t.QR below q.icon\\n  t.QR below r.icon\\n  t.RP below r.icon\\n  t.RP below p.icon\\n}\\n\\nforall Point p\\nwith Triangle T; Point t1, t2, t3\\nwhere T := Triangle(t1, t2, t3); Incenter(p, T) {\\n  override p.vec = incenter(t1.vec, t2.vec, t3.vec)\\n  clr = setOpacity(Colors.darkpurple, 0.6)\\n  T.incenterIcon = Circle {\\n    center : p.vec\\n    r : inradius(t1.vec, t2.vec, t3.vec) - const.strokeWidth\\n    strokeWidth : const.strokeWidth\\n    strokeColor : clr\\n    strokeStyle: \\\"dashed\\\"\\n    fillColor : Colors.none\\n  }\\n  T.incenterIcon below t1.icon\\n  T.incenterIcon below t2.icon\\n  T.incenterIcon below t3.icon\\n}\\n\\nforall Point p\\nwhere Circumcenter(p, T)\\nwith Triangle T {\\n  clr = Colors.darkpurple\\n  override p.icon = Circle {\\n    center : p.vec\\n    r : const.pointRadius\\n    strokeWidth : const.strokeWidth\\n    strokeColor : clr\\n    fillColor : clr\\n  }\\n  p.icon above T.PQ\\n  p.icon above T.QR\\n  p.icon above T.RP\\n  T.icon = Circle {\\n    center : p.vec\\n    r : ?\\n    strokeWidth : const.strokeWidth\\n    strokeColor : clr\\n    fillColor : Colors.none\\n    strokeStyle: \\\"dashed\\\"\\n  }\\n  ensure norm(T.PQ.start - p.vec) == T.icon.r\\n  ensure norm(T.QR.start - p.vec) == T.icon.r\\n  ensure norm(T.RP.start - p.vec) == T.icon.r\\n  encourage repelPt(const.repelWeight, T.PQ.start, T.QR.start)\\n  encourage repelPt(const.repelWeight, T.QR.start, T.RP.start)\\n}\\n\\nforall Point p\\nwhere Centroid(p, T)\\nwith Triangle T {\\n  clr = setOpacity(Colors.darkpurple, 0.6)\\n  override p.vec = vmul(1/3, T.PQ.start + T.QR.start + T.RP.start)\\n  override p.icon = Circle {\\n    center : p.vec\\n    r : const.pointRadius\\n    strokeWidth : const.strokeWidth\\n    strokeColor : clr\\n    fillColor : clr\\n  }\\n  override T.icon = Line {\\n    start : T.PQ.start\\n    end : midpoint(T.QR.start, T.QR.end)\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  override T.line2 = Line {\\n    start : T.QR.start\\n    end : midpoint(T.RP.start, T.RP.end)\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  override T.icon3 = Line {\\n    start : T.RP.start\\n    end : midpoint(T.PQ.start, T.PQ.end)\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n}\\n\\nforall Point p\\nwhere Orthocenter(p, T)\\nwith Triangle T {\\n  clr = setOpacity(Colors.darkpurple, 0.6)\\n  T.icon = Line {\\n    start : (?, ?)\\n    end : p.vec\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  T.icon2 = Line {\\n    start : (?, ?)\\n    end : p.vec\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  T.icon3 = Line {\\n    start : (?, ?)\\n    end : p.vec\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n\\n  -- TODO make it so that predicates can reference other predicates. 3/4 of these are copy-pasted from the Collinear predicate\\n  ensure collinear(T.PQ.start, T.icon.start, T.PQ.end)\\n  ensure collinear(T.QR.start, T.icon2.start, T.QR.end)  \\n  ensure collinear(T.RP.start, T.icon3.start, T.RP.end)\\n\\n  ensure perpendicular(T.PQ.start, T.icon.start, p.vec)\\n  ensure perpendicular(T.QR.start, T.icon2.start, p.vec)  \\n  ensure perpendicular(T.RP.start, T.icon3.start, p.vec)\\n\\n  encourage repelPt(const.repelWeight, T.PQ.start, T.icon.start)\\n  encourage repelPt(const.repelWeight, T.PQ.end, T.icon.start)\\n\\n  encourage repelPt(const.repelWeight, T.QR.start, T.icon2.start)\\n  encourage repelPt(const.repelWeight, T.QR.end, T.icon2.start)\\n\\n  encourage repelPt(const.repelWeight, T.RP.start, T.icon3.start)\\n  encourage repelPt(const.repelWeight, T.RP.end, T.icon3.start)\\n\\n}\\n\\n--Rectangle\\n-- -- Should the rectangle be constructed from the points, or vice versa?\\nforall Rectangle R\\nwhere R := Rectangle(p, q, r, s)\\nwith Point p; Point q; Point r; Point s {\\n  override R.color = Colors.none\\n  override R.icon = Path {\\n      d : pathFromPoints(\\\"closed\\\", [p.icon.center, q.icon.center, r.icon.center, s.icon.center])\\n      strokeWidth : const.strokeWidth\\n      fillColor : R.color\\n      strokeColor : Colors.black\\n    }\\n  ensure vdist(p.icon.center, q.icon.center) == vdist(r.icon.center, s.icon.center)\\n  ensure vdist(p.icon.center, s.icon.center) == vdist(q.icon.center, r.icon.center)\\n\\n  ensure perpendicular(p.icon.center, q.icon.center, r.icon.center)\\n  ensure perpendicular(q.icon.center, s.icon.center, r.icon.center)\\n\\n  -- R.icon above P.icon\\n}\\n\\nforall Quadrilateral Q\\nwhere Q := Quadrilateral(p, q, r, s)\\nwith Point p; Point q; Point r; Point s {\\n  Q.p = p.icon.center\\n  Q.q = q.icon.center\\n  Q.r = r.icon.center\\n  Q.s = s.icon.center\\n\\n  override Q.color = Colors.black\\n  Q.side1 = Line {\\n    start : Q.p\\n    end : Q.q\\n    strokeColor : Q.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  Q.side2 = Line {\\n    start : Q.r\\n    end : Q.q\\n    strokeColor : Q.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  Q.side3 = Line {\\n    start : Q.s\\n    end : Q.r\\n    strokeColor : Q.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  Q.side4 = Line {\\n    start : Q.p\\n    end : Q.s\\n    strokeColor : Q.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }  \\n  Q.labelContainer = Path {\\n    d: pathFromPoints(\\\"closed\\\", [Q.p, Q.q, Q.r, Q.s])\\n    fillColor: none()\\n  }\\n  -- TODO: check if the points actually have labels\\n  ensure disjoint(p.text, Q.labelContainer) in label\\n  ensure disjoint(q.text, Q.labelContainer) in label\\n  ensure disjoint(r.text, Q.labelContainer) in label\\n  ensure disjoint(s.text, Q.labelContainer) in label\\n  -- ensure all sides are visible\\n  ensure norm(Q.p - Q.q) > const.minSegmentLength\\n  ensure norm(Q.q - Q.r) > const.minSegmentLength\\n  ensure norm(Q.r - Q.s) > const.minSegmentLength\\n  ensure norm(Q.s - Q.p) > const.minSegmentLength\\n  ensure norm(Q.r - Q.p) > const.minSegmentLength\\n  ensure norm(Q.s - Q.q) > const.minSegmentLength\\n}\\n\\n--FUNCTIONS\\nforall Segment s\\nwith Triangle T; Point p, q, r, a, b\\nwhere s := MidSegment(T, a, b); T := Triangle(p, q, r) {\\n  override a.vec = midpoint(q.vec, r.vec)\\n  override b.vec = midpoint(r.vec, p.vec)\\n  override s.icon = Line {\\n    start : a.vec\\n    end : b.vec\\n    strokeColor : s.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n}\\n\\nforall Point p\\nwhere p := Midpoint(l)\\nwith Linelike l {\\n  override p.vec = midpoint(l.icon.start, l.icon.end)\\n}\\n\\nforall Point p\\nwhere Midpoint(l, p)\\nwith Linelike l {\\n  override p.vec = midpoint(l.icon.start, l.icon.end)\\n}\\n\\nforall Point p\\nwhere Midpoint(l, p); p has label\\nwith Linelike l {\\n  override p.vec = midpoint(l.icon.start, l.icon.end)\\n  ensure disjoint(p.text, l.icon) in label\\n}\\n\\n-- TODO sometimes bisector becomes a scaled version of either side length PQ or QR of angle PQR\\nforall Linelike s\\nwhere AngleBisector(a, s)\\nwith Angle a; Point p {\\n  weight = 100\\n  angleA = angleBetween(a.p - a.q, s.end - a.q) * weight\\n  angleB = angleBetween(s.end - a.q, a.r - a.q) * weight\\n  bigAngle = angleBetween(a.q - a.p, a.q - a.r) * weight\\n  ensure angleA == angleB \\n  -- HACK: make sure the angle itself is not zero\\n  ensure bigAngle > 15/180 * MathPI() * weight \\n  -- HACK: make sure the bisector end point is between angle end points. Might be too specific\\n  ensure inRange(s.end[0], a.p[0], a.r[0])\\n  ensure inRange(s.end[1], a.p[1], a.r[1])\\n}\\n\\nforall Circle c {\\n  c.radius = const.circleRadius\\n  c.vec = (?, ?)\\n\\n  c.icon = Circle {\\n    center : c.vec\\n    r : c.radius\\n    strokeWidth : const.strokeWidth\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n}\\n\\nforall Circle c\\nwhere c := CircleR(p, q)\\nwith Point p, q {\\n  override c.radius = vdist(p.vec, q.vec)\\n  override c.vec = p.icon.center\\n  override c.icon = Circle {\\n    center : c.vec\\n    r : c.radius\\n    strokeWidth : const.strokeWidth\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n}\\n\\n-- TODO this can be reimplemented when issue #621 is resolved\\n-- Circle c\\n-- where c := CircleD(p, q)\\n-- with Point p, q {\\n--   override c.radius = vdist(p.vec, q.vec) / 2\\n-- }\\n\\nforall Segment s\\nwhere s := Chord(c, p, q)\\nwith Circle c; Point p, q {\\n  override s.vec = q.vec - p.vec\\n  override s.icon = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeColor : s.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n\\n  p.icon above c.icon\\n  q.icon above c.icon\\n  ensure norm(p.vec - c.vec) == c.radius\\n  ensure norm(q.vec - c.vec) == c.radius\\n  ensure norm(q.vec - p.vec) > const.minSegmentLength\\n}\\n\\nforall Segment s\\nwhere s := Chord(c, p, q); p has label; q has label \\nwith Circle c; Point p, q {\\n  ensure disjoint(c.icon, p.text) in label\\n  ensure disjoint(c.icon, q.text) in label\\n}\\n\\nforall Segment s\\nwhere s := Radius(c, p)\\nwith Circle c; Point p {\\n  override s.vec = p.vec - c.vec\\n  override s.icon = Line {\\n    start : c.vec\\n    end : p.icon.center\\n    strokeColor : Colors.black\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  p.icon above c.icon\\n  ensure norm(c.vec - p.vec) == c.radius\\n}\\n\\nforall Segment s\\nwhere s := Radius(c, p); p has label \\nwith Circle c; Point p {\\n  ensure disjoint(p.text, s.icon) in label\\n}\\n\\nforall Segment s\\nwhere s := Radius(c, p); p has label\\nwith Circle c; Point p {\\n  ensure disjoint(p.text, c.icon) in label\\n}\\n\\nforall Segment s\\nwhere s := Diameter(c, p, q)\\nwith Circle c; Point p, q {\\n  override s.vec = q.vec - p.vec\\n  override s.icon = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n    strokeColor : Colors.black\\n  }\\n\\n  p.icon above c.icon\\n  q.icon above c.icon\\n  ensure norm(midpoint(p.vec, q.vec) - c.icon.center) == 0\\n  ensure c.icon.r * 2 == norm(s.vec)\\n}\\n\\nforall Point p\\nwhere OnCircle(c, p)\\nwith Circle c {\\n  ensure norm(c.vec - p.vec) == c.radius\\n}\\n\\nforall Point p\\nwhere OnCircle(c, p); p has label\\nwith Circle c {\\n  ensure disjoint(p.text, c.icon) in label\\n}\\n\\nforall Point p\\nwhere CircleCenter(c, p)\\nwith Circle c {\\n  ensure norm(p.vec - c.vec) == 0\\n}\\n\\nforall Shape s1, s2\\nwhere s1 has label; s2 has label {\\n  encourage notTooClose(s1.text, s2.text)\\n}\";\n//# sourceMappingURL=euclidean.style.js.map","import { makeResolver } from \"../../resolver.js\";\nexport const resolver = makeResolver(\"geometry-domain/textbook_problems\");\nexport default \"global {\\n    shape background = Rectangle {\\n        center: (0, 0)\\n        width: canvas.width\\n        height: canvas.height\\n        fillColor: #DDEDF4\\n    } \\n}\\n\\nforall Point p\\nwith Triangle T; Point t1, t2, t3\\nwhere T := Triangle(t1, t2, t3); Incenter(p, T) {\\n  override T.incenterIcon.strokeColor = setOpacity(Colors.darkpurple, 0.8)\\n}\";\n//# sourceMappingURL=c05p13.style.js.map","export default \"-- ~~~~~~~~~~~~~~~~ TYPES ~~~~~~~~~~~~~~~~\\ntype Shape\\ntype Point <: Shape\\ntype Linelike <: Shape\\ntype Ray <: Linelike\\ntype Line <: Linelike\\ntype Segment <: Linelike\\n\\ntype Angle <: Shape\\n\\ntype Triangle <: Shape\\ntype Quadrilateral <: Shape\\ntype Rectangle <: Quadrilateral\\ntype Circle <: Shape\\n\\ntype Plane <: Shape\\n\\n-- ~~~~~~~~~~~~~~~~ CONSTRUCTORS ~~~~~~~~~~~~~~~~\\n-- Lines and Points\\nconstructor Segment(Point p, Point q)\\nconstructor Ray(Point base, Point direction)\\nconstructor Line(Point p, Point q)\\nconstructor Midpoint(Linelike l) -> Point\\n\\n-- Angles\\nconstructor InteriorAngle(Point p, Point q, Point r) -> Angle\\n\\n-- Polygons/Shapes\\nconstructor Triangle(Point p, Point q, Point r)\\nconstructor Rectangle(Point p, Point q, Point r, Point s)\\nconstructor Quadrilateral(Point p, Point q, Point r, Point s)\\nconstructor CircleR(Point center, Point radius) -> Circle\\n-- constructor CircleD(Point diam1, Point diam2) -> Circle  -- TODO can be reimplemented when #621 is resolved\\n\\n-- ~~~~~~~~~~~~~~~~ FUNCTIONS ~~~~~~~~~~~~~~~~\\n-- Lines and Points\\nfunction Bisector(Angle) -> Ray\\nfunction PerpendicularBisector(Segment, Point) -> Segment\\nfunction PerpendicularBisectorLabelPts(Segment, Point, Point) -> Segment -- same as PerpendicularBisector but it takes a segment + 2 points as args for labeling\\n\\n-- Polygons/Shapes\\nfunction MidSegment(Triangle, Point, Point) -> Segment\\nfunction Radius(Circle c, Point p) -> Segment\\nfunction Chord(Circle c, Point p, Point q) -> Segment\\nfunction Diameter(Circle c, Point p, Point q) -> Segment\\n\\n-- Unimplemented\\n-- function Sum(Angle, Angle) -> Angle\\n-- function Intersection(Linelike, Linelike) -> Point\\n-- function Altitude(Triangle, Angle) -> Segment\\n-- function Endpoint(Segment) -> Point\\n\\n-- ~~~~~~~~~~~~~~~~ PREDICATES ~~~~~~~~~~~~~~~~\\n-- Lines and Points\\npredicate On(Point, Linelike)\\npredicate In(Point, Plane)\\npredicate Midpoint(Linelike, Point)\\npredicate Collinear(Point, Point, Point)\\npredicate ParallelMarker1(Linelike, Linelike)\\npredicate EqualLengthMarker(Linelike, Linelike)\\npredicate EqualLength(Linelike, Linelike)\\npredicate Parallel(Linelike, Linelike)\\n\\n-- Angles\\npredicate Acute(Angle) \\npredicate Obtuse(Angle) \\npredicate RightMarked(Angle)\\npredicate RightUnmarked(Angle)\\npredicate AngleBisector(Angle, Linelike)\\npredicate EqualAngleMarker(Angle, Angle)\\npredicate EqualAngle(Angle, Angle)\\n\\n-- Polygons/Shapes\\npredicate Parallelogram(Quadrilateral)\\npredicate OnCircle(Circle, Point)\\npredicate CircleCenter(Circle, Point)\\npredicate Incenter(Point, Triangle)\\npredicate Orthocenter(Point, Triangle)\\npredicate Centroid(Point, Triangle)\\npredicate Circumcenter(Point, Triangle)\\n\\n-- notation \\\"{p, q}\\\" ~ \\\"Segment(p, q)\\\"\\n-- notation \\\"{p, q, r}\\\" ~ \\\"Triangle(p, q, r)\\\"\\n-- notation \\\"{p, q, r, s}\\\" ~ \\\"Rectangle(p, q, r, s)\\\"\\n-- notation \\\"∠(p, q, r)\\\" ~ \\\"InteriorAngle(p, q, r)\\\"\";\n//# sourceMappingURL=geometry.domain.js.map","import substance from \"./c05p13.substance.js\";\nimport style0, { resolver as resolver0 } from \"../euclidean.style.js\";\nimport style1, { resolver as resolver1 } from \"./c05p13.style.js\";\nimport domain from \"../geometry.domain.js\";\nexport default {\n    substance,\n    style: [\n        { contents: style0, resolver: resolver0 },\n        { contents: style1, resolver: resolver1 },\n    ],\n    domain,\n    variation: \"RationalityZebra567\",\n    excludeWarnings: [\"BBoxApproximationWarning\"]\n};\n//# sourceMappingURL=c05p13.trio.js.map","export default \"-- A short walk used to estimate the solution to\\n-- a Laplace equation Δu = 0 with pure Dirichlet\\n-- boundary conditions, via WoS.\\n\\nDomain U\\n\\nPoint x0\\nBall B0 := ballAround( x0 )\\nPoint x1 := sampleBoundary( B0 )\\nBall B1 := ballAround( x1 )\\nPoint x2 := sampleBoundary( B1 )\\nBall B2 := ballAround( x2 )\\nPoint x3 := sampleBoundary( B2 )\\nBall B3 := ballAround( x3 )\\nPoint x4 := sampleBoundary( B3 )\\nBall B4 := ballAround( x4 )\\n\\nLabel U  $\\\\Omega$\\nLabel x0 $x_0$\\nLabel x1 $x_1$\\nLabel x2 $x_2$\\nLabel x3 $\\\\ldots$\\nLabel x4 $x_k$\\n\\n\";\n//# sourceMappingURL=Laplace.substance.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"walk-on-spheres\");\nexport default \"layout = [ walkStage, nestStage, labelStage, legendStage ]\\n\\n-- diagram dimensions (in px; multiply by 96/72 to convert to pt)\\ncanvas {\\n   width = 200 -- ==150pt\\n   height = 200 -- ==150pt\\n}\\n\\n-- some colors re-used throughout\\nColors {\\n   color black = rgba(0,0,0,1)\\n   color white = rgba(1,1,1,1)\\n   color darkGray = #b3b3b3\\n   color lightGray = #e5e5e5\\n   color deepGreen = #93c697\\n}\\n\\n-- global shapes and constants\\nGlobal {\\n   scalar toPt = 96/72 -- constant for converting sizes from pt to px\\n\\n   -- default appearance for label text\\n   string labelFont = \\\"Linux Libertine\\\"\\n   string labelSize = \\\"13.333px\\\" -- equivalent to 10pt (multiply by 96/72)\\n   scalar labelHeight = toPt * 10\\n   color labelColor = Colors.black\\n   color subdomainLabelColor = Colors.deepGreen\\n   color labelStrokeColor = Colors.white\\n   scalar labelStrokeWidth = toPt * 1.5\\n\\n   -- appearance of dots/points\\n   scalar dotSize = toPt * 1.5\\n   scalar openDotWidth = toPt * 0.5\\n   scalar dotLabelDistance = 9\\n\\n   -- style of domains/subdomains\\n   color domainColor = Colors.lightGray\\n   color ballColor = rgba(154/255.,204/255.,160/255.,1)\\n   color sphereColor = rgba(27/255.,138/255.,31/255.,1)\\n   scalar subdomainOpacity = .35\\n   scalar sphereStrokeWidth = toPt * .5\\n   scalar domainStrokeWidth = toPt * 1\\n   scalar dirichletStrokeWidth = domainStrokeWidth\\n   scalar neumannStrokeWidth = .65*domainStrokeWidth\\n   string neumannDash = \\\"2.66,2.66\\\" -- \\\"2,2\\\"\\n   scalar labelPadding = 6\\n\\n   -- style of lines along a walk\\n   -- (set color to none() to disable)\\n   color walkColor = #0066004c\\n   scalar walkStrokeWidth = toPt * 1\\n\\n}\\n\\nforall Domain D {\\n   -- draw the domain as a polygon with some random variation, by\\n   -- perturbing the vertices of a hexagon by some bounded amount\\n   -- Note: if the domain shape is changed to something else (like\\n   -- an ellipse or a rectangle), things _should_ still work as\\n   -- expected, since later methods just make a call to `signedDistance`\\n   -- to determine ball radii.  However, signed distance may not yet\\n   -- be supported for all shapes (like arbitrary Bézier curves).\\n   scalar maxPerturbation = 15\\n   scalar w = .8*canvas.width/2\\n   scalar h = .8*canvas.height/2\\n   vec2 D.p0 = ( w, -h) + maxPerturbation*diskRandom()\\n   vec2 D.p1 = ( 0, -h) + maxPerturbation*diskRandom()\\n   vec2 D.p2 = (-w, -h) + maxPerturbation*diskRandom()\\n   vec2 D.p3 = (-w,  h) + maxPerturbation*diskRandom()\\n   vec2 D.p4 = ( 0,  h) + maxPerturbation*diskRandom()\\n   vec2 D.p5 = ( w,  h) + maxPerturbation*diskRandom()\\n   shape D.geometry = Polygon {\\n      points: [ D.p0, D.p1, D.p2, D.p3, D.p4, D.p5 ]\\n      fillColor: Colors.lightGray\\n      strokeColor: Colors.darkGray\\n      strokeWidth: Global.domainStrokeWidth\\n      ensureOnCanvas: false\\n   }\\n}\\n\\n-- label the domain if it was assigned a label in the Substance program\\nforall Domain D\\nwhere D has label {\\n\\n   scalar x = ? in labelStage\\n   scalar y = ? in labelStage\\n   shape D.labelText = Equation {\\n      string: D.label\\n      center: (x,y)\\n      fontSize: Global.labelSize\\n      fontFamily: Global.labelFont\\n      fillColor: Colors.black\\n      ensureOnCanvas: false\\n   }\\n\\n   ensure lessThan( signedDistance( D.geometry, D.labelText.center ), -9. ) in labelStage\\n   layer D.labelText above D.geometry -- make sure the label doesn't get covered by the domain shape\\n}\\n\\nforall Domain D\\nwhere hasMixedBoundaryConditions( D ) {\\n   override D.geometry.strokeColor = none()\\n\\n   shape D.poly0 = Polyline {\\n      points: ( D.p5, D.p0 )\\n      strokeColor: Colors.black\\n      strokeWidth: Global.dirichletStrokeWidth\\n      strokeLinecap: \\\"round\\\"\\n      ensureOnCanvas: false\\n   }\\n   shape D.poly1 = Polyline {\\n      points: ( D.p0, D.p1, D.p2 )\\n      strokeColor: Colors.black\\n      strokeWidth: Global.neumannStrokeWidth\\n      ensureOnCanvas: false\\n      style: \\\"dashed\\\"\\n      strokeDasharray: Global.neumannDash\\n   }\\n   shape D.poly2 = Polyline {\\n      points: ( D.p2, D.p3 )\\n      strokeColor: Colors.black\\n      strokeWidth: Global.dirichletStrokeWidth\\n      strokeLinecap: \\\"round\\\"\\n      ensureOnCanvas: false\\n   }\\n   shape D.poly3 = Polyline {\\n      points: ( D.p3, D.p4, D.p5 )\\n      strokeColor: Colors.black\\n      strokeWidth: Global.neumannStrokeWidth\\n      ensureOnCanvas: false\\n      style: \\\"dashed\\\"\\n      strokeDasharray: Global.neumannDash\\n   }\\n\\n   shape D.dirichletBoundary = Group {\\n      shapes: ( D.poly0, D.poly2 )\\n      ensureOnCanvas: false\\n   }\\n   shape D.neumannBoundary = Group {\\n      shapes: ( D.poly1, D.poly3 )\\n      ensureOnCanvas: false\\n   }\\n\\n   layer D.dirichletBoundary above D.geometry\\n   layer D.neumannBoundary above D.dirichletBoundary\\n}\\n\\n-- draw each point as a small dot\\nforall Point p {\\n   scalar x = ? in walkStage\\n   scalar y = ? in walkStage\\n   vec2 p.location = (x,y)\\n\\n   -- The `dot` shape represents the sample point associated\\n   -- with the ball.  Ordinarily this point will be at the\\n   -- center of the ball, but in general it could be at a\\n   -- different location (e.g., for an off-center walk).\\n   shape p.dot = Circle {\\n      center: p.location\\n      r: Global.dotSize\\n      fillColor: Colors.black\\n      ensureOnCanvas: false\\n   }\\n}\\n\\n-- draw each Ball as the largest ball tangent to the domain boundary\\nforall Ball B; Domain D {\\n\\n   -- Make sure the ball is inside the problem domain by\\n   -- setting its radius to (minus) the signed distance to\\n   -- the domain boundary.  This value is negated since, by\\n   -- convention, points inside the domain have negative\\n   -- signed distance.\\n   scalar x = ? in walkStage\\n   scalar y = ? in walkStage\\n   vec2 B.center = (x,y)\\n   scalar B.radius = -signedDistance( D.geometry, B.center ) - Global.sphereStrokeWidth/2 - Global.domainStrokeWidth/2.\\n\\n   -- The `ball` shape is a flat-shaded semi-transparent\\n   -- disk that determines the color of the ball.\\n   -- The ball radius equals the distance from the\\n   -- ball center to the closest point on the domain boundary\\n   -- (just as in the WoS algorithm!).  We also subtract half\\n   -- the stroke widths so that visually the ball makes perfect\\n   -- tangential contact with the domain boundary.\\n   -- Note that we don't need to\\n   -- explicitly enforce that the ball remains on the canvas,\\n   -- since the domain shape already has an onCanvas constraint,\\n   -- and the balls are always contained in the domain shape, by\\n   -- construction.\\n   shape B.ball = Circle {\\n      center: B.center\\n      r: B.radius\\n      fillColor: Global.ballColor\\n      strokeColor: Global.sphereColor\\n      strokeWidth: Global.sphereStrokeWidth\\n      opacity: Global.subdomainOpacity\\n      ensureOnCanvas: false\\n   }\\n\\n   shape B.shading = Image {\\n      href: \\\"ball-shading.svg\\\"\\n      center: B.ball.center\\n      width: 2*B.ball.r\\n      height: 2*B.ball.r\\n      ensureOnCanvas: false\\n   }\\n\\n   -- Make sure all components of the ball get drawn in the\\n   -- proper order, and are not covered up by the domain shape.\\n   layer B.ball above B.shading\\n   layer B.shading above D.geometry\\n\\n   -- This constant determines how much balls shrink from one\\n   -- step of the walk to the next.  We define it as a named\\n   -- constant so that specialized types of balls (say, those\\n   -- coming from a nested walk) can use a different factor.\\n   scalar B.shrinkFactor = .55\\n}\\n\\n-- If a ball is constructed around a point, center it around that point\\nforall Point p; Ball B\\nwhere B := ballAround( p ) {\\n   override B.center = p.location\\n   layer p.dot above B.ball\\n}\\n\\n-- For a step of an off-centered walk, we want to clearly\\n-- indicate that the sample point may not be at the ball center.\\nforall Ball B; Point p\\nwhere B := ballAround(p); isOffCenter(B) {\\n\\n   -- We can no longer just copy the ball center from the point center,\\n   -- but will instead let the layout engine determine its location.\\n   scalar x = ? in walkStage\\n   scalar y = ? in walkStage\\n   override B.center = (x,y)\\n\\n   -- Still keep the center within the middle 25–75% of the ball, since\\n   -- the dot may be hard to see if it gets too close to the boundary\\n   -- (especially for very small balls).\\n   scalar r = B.radius * random(.25,.75)\\n   ensure norm(B.center - p.location) == r in walkStage\\n}\\n\\n-- If a point has a label, draw a label string near the dot.\\nforall Point p\\nwhere p has label {\\n   shape p.labelText = Equation {\\n      string: p.label\\n      fontSize: Global.labelSize\\n      fontFamily: Global.labelFont\\n      fontStyle: \\\"italic\\\"\\n      fillColor: Global.labelColor\\n      --strokeColor: Global.labelStrokeColor\\n      --strokeWidth: Global.labelStrokeWidth\\n      --strokeLinejoin: \\\"round\\\"\\n      --paintOrder: \\\"stroke\\\"\\n      ensureOnCanvas: false\\n   }\\n\\n   -- We want the label to be near the dot, but don't want it\\n   -- to overlap the dot (which makes it hard to read).\\n   scalar theta = ? in labelStage\\n   p.labelText.center = p.dot.center + Global.dotLabelDistance*( cos(theta), sin(theta) )\\n\\n   -- If we fail to avoid overlap, we should\\n   -- at least draw the label on top of the dot\\n   layer p.labelText above p.dot\\n}\\n\\n-- Make sure a point's label doesn't get covered by a ball\\n-- containing it, by layering it above the topmost ball shape.\\nforall Point p; Ball B\\nwhere B := ballAround( p ); p has label {\\n   layer p.labelText above B.ball\\n}\\n\\n-- If a point p is sampled from the boundary of a ball B,\\n-- make sure it sits on the corresponding sphere ∂B.\\nforall Ball B; Point p\\nwhere p := sampleBoundary( B ) {\\n   constraint p.ballConstraint = ensure equal( norm(p.location - B.center), B.radius ) in walkStage\\n\\n   -- Make sure the dot is not covered by the sphere.\\n   layer p.dot above B.ball\\n}\\n\\n-- If a point p is sampled from the interior of a ball B,\\n-- make sure it sits somewhere between 20% and 80% away\\n-- from the center, so that it's clearly visible and doesn't\\n-- run into the center point or the boundary.\\nforall Ball B; Point p\\nwhere p := sampleInterior( B ) {\\n   scalar r = B.radius * random(.2,.8)\\n   constraint p.ballConstraint = ensure norm( p.location - B.center ) == r in walkStage\\n\\n   -- Make sure the dot is not covered by the ball.\\n   layer p.dot above B.ball\\n}\\n\\n\\n-- Adjust the drawing for consecutive steps x0, x1 along a walk on spheres,\\n-- where B0, B1 are the associated spheres.\\nforall Ball B0; Ball B1; Point x0; Point x1\\nwhere x1 := sampleBoundary( B0 ); B0 := ballAround( x0 ); B1 := ballAround( x1 ) {\\n   -- draw later steps of a walk as smaller balls (which is often, but\\n   -- not always, the behavior of the WoS algorithm)\\n   ensure equal( B1.radius, B1.shrinkFactor * B0.radius ) in walkStage\\n\\n   -- It's typically easier to see labels, etc., if later, smaller\\n   -- balls are drawn on top of earlier, bigger ones.\\n   layer B1.ball above B0.ball\\n}\\n\\n-- Draw a line between the consecutive points on a walk on spheres\\nforall Point x0; Point x1; Ball B0; Domain D\\nwhere x1 := sampleBoundary( B0 ); B0 := ballAround( x0 ) {\\n\\n   shape x1.walkLine = Line {\\n      start: x0.location\\n      end: x1.location\\n      fill: \\\"none\\\"\\n      strokeColor: Global.walkColor\\n      strokeWidth: Global.walkStrokeWidth\\n      ensureOnCanvas: false\\n   }\\n   layer x1.walkLine above D.geometry\\n\\n   -- Use layering to help clarify the direction of the walk.\\n   layer x1.walkLine above B0.ball\\n}\\n\\nforall Point x0; Point x1; Ball B0; Ball B1; Domain D\\nwhere x1 := sampleBoundary( B0 ); B0 := ballAround( x0 ); B1 := ballAround( x1 ) {\\n   -- Use layering to help clarify the direction of the walk.\\n   layer x1.walkLine below B1.ball\\n}\\n\\n-- Draw sample points that are used to estimate the source term\\n-- as just dots contained in the ball of interest.  These sample\\n-- points are different from steps of a walk, since we never\\n-- need to consider a ball around these points (and hence do not\\n-- want to draw one).\\nforall Point p; Ball B\\nwhere p := sampleInterior( B ); isSourceSample( p ) {\\n   scalar x = ? in walkStage\\n   scalar y = ? in walkStage\\n   -- Draw source samples in a different style\\n   override p.location = (x,y)\\n   override p.dot.r = 2\\n   override p.dot.fillColor = Colors.white\\n   override p.dot.strokeColor = Colors.black\\n   override p.dot.strokeWidth = 1\\n}\\n\\n-- Nested walks --------------------------------------------\\n\\n-- Draw nested points in a different style\\nforall NestedPoint p {\\n   scalar x = ? in nestStage\\n   scalar y = ? in nestStage\\n   vec2 p.location = (x,y)\\n\\n   shape p.dot = Circle {\\n      center: p.location\\n      r: 2.5\\n      fillColor: Colors.white\\n      ensureOnCanvas: false\\n   }\\n}\\n\\n-- Draw nested balls in a different style\\nforall Ball B; NestedPoint p\\nwhere B := nestedBallAround(p) {\\n\\n   override B.center = p.location\\n\\n   -- Change to a color palette that is more white & opaque.\\n   override B.ball.fillColor = none()\\n   override B.ball.strokeColor = none()\\n   override B.shading = Circle{\\n      center: B.center\\n      r: B.radius\\n      fillColor: rgba(1,1,1,.2)\\n      strokeColor: rgba(1,1,1,.5)\\n      strokeWidth: 1\\n      ensureOnCanvas: false\\n   }\\n\\n   override B.shrinkFactor = .7\\n}\\n\\nforall NestedPoint p; Point p0; Ball B; Ball B0; Domain D\\nwhere p := startWalkFrom(B0); B := nestedBallAround(p); B0 := ballAround(p0) {\\n   vec2 y = closestPoint( D.geometry, B0.center )\\n   scalar u = .75\\n   override p.location = (1-u)*B0.center + u*y\\n   override B.center = p.location\\n   override B.radius = norm( y - p.location )\\n}\\n\\nforall NestedPoint p; Ball B\\nwhere p := sampleBoundaryNested(B) {\\n   ensure norm(p.location - B.center) == B.radius in nestStage\\n}\\n\\nforall Ball B0; Ball B1; NestedPoint x0; NestedPoint x1\\nwhere x1 := sampleBoundaryNested( B0 ); B0 := nestedBallAround( x0 ); B1 := nestedBallAround( x1 ) {\\n   ensure equal( B1.radius, B1.shrinkFactor * B0.radius ) in nestStage\\n}\\n\\nforall Ball B; NestedPoint p; Ball B0; Point p0\\nwhere B := nestedBallAround(p); B0 := ballAround(p0) {\\n   layer B.ball above B0.ball\\n}\\n\\n-- Draw a line between the consecutive points on a nested walk\\nforall NestedPoint x0; NestedPoint x1; Ball B0; Domain D\\nwhere x1 := sampleBoundaryNested( B0 ); B0 := nestedBallAround( x0 ) {\\n\\n   shape x1.walkLine = Line {\\n      start: x0.location\\n      end: x1.location\\n      fill: \\\"none\\\"\\n      strokeColor: Colors.white\\n      strokeWidth: Global.walkStrokeWidth\\n      ensureOnCanvas: false\\n   }\\n   layer x1.walkLine above D.geometry\\n\\n   -- Use layering to help clarify the direction of the walk.\\n   layer x1.walkLine above B0.ball\\n}\\n\\n-- draw nested walks above regular walks\\nforall NestedPoint p; Ball B {\\n   layer p.dot above B.ball\\n}\\n\\n-- Walk on Stars -------------------------------------------\\n\\n-- If the domain has mixed boundary conditions (and\\n-- hence we're using walk on stars), we want to keep\\n-- track of the normal at point p, which we'll set\\n-- to zero if p is not on the domain boundary.\\nforall Domain D; Point p\\nwhere hasMixedBoundaryConditions( D ) {\\n\\n   override p.location = triangleRandom( D.p0, D.p2, D.p3 )\\n\\n   vec2 p.normal = (0,0)\\n\\n   -- rays from p will be sampled from baseAngle + [-angleRange,angleRange]\\n   scalar p.baseAngle = 0\\n   scalar p.angleRange = MathPI()\\n\\n   layer p.dot above D.neumannBoundary\\n\\n   -- -- draw an arrow for the normal at p (transparent if the normal is zero)\\n   -- scalar eps = 1e-7 -- prevents NaNs for zero-length normals\\n   -- shape p.normalArrow = Line {\\n   --    start: p.location\\n   --    end: p.location + 20*p.normal + eps*(1,1)\\n   --    fill: \\\"none\\\"\\n   --    strokeWidth: 1\\n   --    strokeColor: rgba(1,1,1,.5*norm(p.normal))\\n   --    ensureOnCanvas: false\\n   --    endArrowhead: \\\"straight\\\"\\n   --    endArrowheadSize: .5\\n   -- }\\n   -- layer p.normalArrow below p.dot\\n}\\n\\nforall Star St; Point p; Domain D\\nwhere St := starAround(p) {\\n   vec2 yDirichlet = closestPoint( D.dirichletBoundary, p.location )\\n   scalar St.dDirichlet = norm( yDirichlet - p.location )\\n   scalar St.dNeumann = closestSilhouetteDistance( D.neumannBoundary, p.location )\\n   scalar rMin = 1\\n   scalar R = max( rMin, min( St.dDirichlet, St.dNeumann ))\\n\\n   -- color the boundary of the ball according to whether it's defined\\n   -- by the closest Dirichlet point or closest Neumann silhouette point\\n   scalar upsilon = 1e-7 -- to fudge the case where dDirichlet==dNeumann\\n   scalar t = (St.dDirichlet - R)/(St.dDirichlet - St.dNeumann + upsilon)\\n   -- vec3 c0 = (.4,.6,.4)\\n   -- vec3 c1 = (.4,.4,.7)\\n   vec3 f0 = (154,204,160)/255.\\n   vec3 f1 = (255,255,255)/255.\\n   vec3 s0 = (27,138,31)/255.\\n   vec3 s1 = (27,138,31)/255.\\n   vec3 s = (1-t)*s0 + t*s1\\n   vec3 f = (1-t)*f0 + t*f1\\n\\n   shape St.ball = Circle {\\n      center: p.location\\n      r: R\\n      fillColor: rgba( f[0], f[1], f[2], 1 )\\n      strokeColor: rgba( s[0], s[1], s[2], 1 )\\n      strokeWidth: Global.sphereStrokeWidth\\n      ensureOnCanvas: false\\n      opacity: .35\\n   }\\n\\n   shape St.shading = Image {\\n      href: \\\"ball-shading.svg\\\"\\n      center: St.ball.center\\n      width: 2*St.ball.r\\n      height: 2*St.ball.r\\n      ensureOnCanvas: false\\n   }\\n\\n   layer St.shading above D.geometry\\n   layer St.ball above St.shading\\n\\n   shape St.domainGeometry = Polygon {\\n      points: D.geometry.points\\n      fillColor: none()\\n      ensureOnCanvas: false\\n   }\\n   shape St.G = Group {\\n      shapes: [St.ball,St.shading]\\n      clipPath: clip(St.domainGeometry)\\n      ensureOnCanvas: false\\n   }\\n   layer St.G above D.geometry\\n   layer St.G below D.neumannBoundary\\n}\\n\\nforall Point p; Star St {\\n   layer p.dot above St.ball\\n}\\n\\nforall Point p0; Point p1; Star St; Domain D\\nwhere p1 := sampleBoundary(St); St := starAround(p0) {\\n\\n   -- sample a random ray from p0\\n   scalar theta = p0.baseAngle + p0.angleRange * random(-1,1)\\n   scalar eps = 1e-1 -- offset ray origin to avoid intersecting at x again\\n   vec2 v = ( cos(theta), sin(theta) )\\n   vec2 x = p0.location + eps*v\\n\\n   -- intersect the star boundary\\n   scalar tBoundary = rayIntersectDistance( D.neumannBoundary, x, v )\\n   scalar tBall = St.ball.r\\n   scalar t = min( tBoundary, tBall )\\n   override p1.location = x + t*v \\n\\n   -- set the normal at the intersection point, or set it to zero if\\n   -- the ray hits the ball boundary first\\n   vec2 n = rayIntersectNormal( D.neumannBoundary, x, v )\\n   scalar k = 100. -- steepness parameter for indicator function\\n   scalar s = 1. - exp(-k*sqr(t - tBall)) -- equals zero near tBall and 1 otherwise\\n   override p1.normal = s * n -- scales n to zero if t == tBall\\n   override p1.angleRange = (1-s/2)*MathPI() -- s=0 -> MathPI(); s=1 -> MathPI()/2\\n   scalar delta = 1e-7 -- to get valid angle if normal is zero\\n   override p1.baseAngle = atan2( p1.normal[0], p1.normal[1] + delta )\\n\\n   -- draw the point in white if it's on the Neumann boundary\\n   override p1.dot.fillColor = rgba(s,s,s,1)\\n   override p1.dot.strokeWidth = .5*s\\n   override p1.dot.strokeColor = rgba(0,0,0,1)\\n\\n   -- draw the walk line from p0 to p1\\n   shape p1.walkLine = Line {\\n      start: p0.location\\n      end: p1.location -- - Global.dotSize*v\\n      fill: \\\"none\\\"\\n      strokeColor: Global.walkColor\\n      strokeWidth: Global.walkStrokeWidth\\n      --endArrowhead: \\\"straight\\\"\\n      --endArrowheadSize: .5\\n      ensureOnCanvas: false\\n      strokeLinecap: \\\"round\\\"\\n   }\\n\\n   layer p0.dot above p1.walkLine\\n   layer D.dirichletBoundary above p1.walkLine\\n}\\n\\nforall Point p0; Point p1; Star St; Domain D; Star St2\\nwhere p1 := sampleBoundary(St); St := starAround(p0) {\\n   layer p1.walkLine above St2.ball\\n}\\n\\n-- connect the walk to the closest point on the\\n-- Dirichlet boundary, and draw the boundary point\\n-- in a different style\\nforall Point q; Point p; Domain D\\nwhere q := closestBoundaryPoint( D, p ); hasMixedBoundaryConditions( D )\\n{\\n   override q.dot.center = closestPoint( D.dirichletBoundary, p.location )\\n   override q.dot.fillColor = Colors.white\\n   override q.dot.strokeColor = Colors.black\\n   override q.dot.strokeWidth = Global.openDotWidth\\n\\n   shape q.walkLine = Line {\\n      start: p.dot.center\\n      end: q.dot.center\\n      fill: \\\"none\\\"\\n      strokeColor: Global.walkColor\\n      strokeWidth: Global.walkStrokeWidth\\n      ensureOnCanvas: false\\n   }\\n\\n   layer q.walkLine above D.geometry\\n   layer q.dot above q.walkLine\\n}\\n\\n-- Rays ---------------------------------------\\n\\nforall Ray r; Domain D {\\n   vec2 r.x = (0,0) -- origin\\n   scalar r.L = 30 -- length\\n   scalar r.theta = 0 -- angle\\n   vec2 r.v = ( cos(r.theta), sin(r.theta) ) -- direction\\n\\n   vec2 s = 2.0 -- size\\n   vec2 a = r.x -- start\\n   vec2 b = r.x + r.L*r.v -- end\\n\\n   scalar w = .75\\n   vec2 u = unit(b-a)\\n   vec2 n = rot90(u)\\n   shape r.taperedStroke = Polygon {\\n      points: ( a, b + w*n - 3.5*u, b - w*n - 3.5*u )\\n      fillColor: #ff4411\\n      ensureOnCanvas: false\\n   }\\n\\n   shape r.arrowHead = Line {\\n      start: b - 6.5*u\\n      end: b\\n      strokeColor: #ff4411\\n      strokeWidth: Global.walkStrokeWidth\\n      endArrowhead: \\\"straight\\\"\\n      endArrowheadSize: .5\\n      ensureOnCanvas: false\\n   }\\n\\n   shape r.icon = Group {\\n      shapes: [ r.taperedStroke, r.arrowHead ]\\n      ensureOnCanvas: false\\n      opacity: .75\\n   }\\n\\n   layer r.icon above D.geometry\\n}\\n\\n\\nforall Ray r; Point p\\nwhere p := headOf( r )\\n{\\n   override p.location = r.arrowHead.end\\n   override p.dot.fillColor = Colors.white\\n   override p.dot.strokeColor = Colors.black\\n   override p.dot.strokeWidth = Global.openDotWidth\\n   layer p.dot above r.icon\\n}\\n\\n\\n-- Labeling ------------------------------------------------\\n\\nforall Subdomain S; Domain D\\nwhere S has label {\\n   shape S.labelText = Equation {\\n      string: S.label\\n      fontSize: Global.labelSize\\n      fontFamily: Global.labelFont\\n      fontStyle: \\\"italic\\\"\\n      fillColor: Global.subdomainLabelColor\\n      ensureOnCanvas: false\\n   }\\n\\n   -- encourage near( S.labelText, S.ball ) in labelStage\\n   encourage norm( S.labelText.center - S.ball.center ) == S.ball.r/2 in labelStage\\n   encourage lessThan( signedDistance( D.geometry, S.labelText.center ), -2. ) in labelStage\\n}\\n\\n-- Make sure the domain's label isn't covered up by a ball.\\nforall Ball B; Domain D\\nwhere D has label {\\n   scalar padding = 10.\\n   ensure disjoint( D.labelText, B.ball, padding ) in labelStage\\n}\\n\\n-- Put all labels above all balls\\nforall Point p; Ball B\\nwhere p has label {\\n   layer p.labelText above B.ball\\n}\\n\\n-- Put all labels above all dots and\\n-- encourage labels not to overlap\\nforall Point p; Point q\\nwhere p has label; q has label {\\n   layer p.labelText above q.dot\\n   layer q.labelText above p.dot\\n\\n   vec2 px = p.location\\n   vec2 qx = q.location\\n   vec2 pc = p.labelText.center\\n   vec2 qc = q.labelText.center\\n   encourage 10000./norm(pc - qc) == 0. in labelStage\\n}\\n\\nforall Point p; Point q\\nwhere p has label {\\n   layer p.labelText above q.dot\\n}\\n\\nforall Point p; Point q\\nwhere p has label; isSourceSample(q) {\\n   vec2 pc = p.labelText.center\\n   vec2 qx = q.location\\n   encourage 1000./norm(pc - qx) == 0. in labelStage\\n}\\n\\nforall Point p; Domain D\\nwhere p has label; hasMixedBoundaryConditions(D) {\\n   layer p.labelText above D.dirichletBoundary\\n}\\n\\n-- Make sure domain label doesn't overlap stars\\nforall Subdomain S; Domain D\\nwhere D has label {\\n   constraint S.avoidDomainLabel = ensure disjoint( D.labelText, S.ball ) in labelStage\\n}\\n\\n-- Make sure subdomain labels don't overlap points or their labels\\nforall Subdomain S; Point p\\nwhere S has label {\\n   ensure disjoint( S.labelText, p.dot, Global.labelPadding ) in labelStage\\n}\\nforall Subdomain S; Point p\\nwhere S has label; p has label {\\n   ensure disjoint( S.labelText, p.labelText, Global.labelPadding ) in labelStage\\n}\\n\\n\\n-- Legend ---------------------------------------\\n\\nforall Domain D\\nwhere hasLegend(D) {\\n   shape D.legendBox = Rectangle {\\n      center: ( ? in legendStage, ? in legendStage )\\n      width: ? in legendStage\\n      height: ? in legendStage\\n      fillColor: #fff\\n      strokeColor: #000\\n      strokeWidth: 1\\n   }\\n   encourage D.legendBox.width == 0 in legendStage\\n   encourage D.legendBox.height == 0 in legendStage\\n}\\n\\nforall Domain D\\nwhere hasLegend(D); hasMixedBoundaryConditions(D) {\\n\\n   scalar itemSpacing = 1.5 * Global.labelHeight\\n   scalar segmentWidth = 1 * itemSpacing\\n   scalar textSpacing = 2.5*Global.labelHeight\\n   scalar padding = 8\\n\\n   vec2 x0 = ( ? in legendStage, ? in legendStage )\\n   encourage norm(x0-(canvas.width,-canvas.height)) == 0 in legendStage\\n\\n   shape dirichletLine = Line {\\n      start: x0\\n      end: x0 + (segmentWidth,0)\\n      fill: \\\"none\\\"\\n      strokeWidth: Global.dirichletStrokeWidth\\n      strokeColor: #000\\n      style: \\\"dashed\\\"\\n      ensureOnCanvas: false\\n   }\\n\\n   shape neumannLine = Line {\\n      start: x0 + (0,-itemSpacing)\\n      end: x0 + (segmentWidth,-itemSpacing)\\n      fill: \\\"none\\\"\\n      strokeWidth: Global.neumannStrokeWidth\\n      strokeColor: #000\\n      style: \\\"dashed\\\"\\n      strokeDasharray: \\\"2,2\\\"\\n      ensureOnCanvas: false\\n   }\\n\\n   shape dirichletLegend = Text {\\n      center: dirichletLine.end + (textSpacing,0)\\n      string: \\\"Dirichlet\\\"\\n      fontFamily: Global.labelFont\\n      fontSize: Global.labelSize\\n      fillColor: Global.labelColor\\n      ensureOnCanvas: false\\n   }\\n\\n   shape neumannLegend = Text {\\n      center: neumannLine.end + (textSpacing,0)\\n      string: \\\"Neumann\\\"\\n      fontFamily: Global.labelFont\\n      fontSize: Global.labelSize\\n      fillColor: Global.labelColor\\n      ensureOnCanvas: false\\n   }\\n\\n   ensure contains( D.legendBox, dirichletLegend, padding ) in legendStage\\n   ensure contains( D.legendBox, dirichletLine, padding ) in legendStage\\n   ensure contains( D.legendBox, neumannLegend, padding ) in legendStage\\n   ensure contains( D.legendBox, neumannLine, padding ) in legendStage\\n\\n   layer D.legendBox below dirichletLegend\\n   layer D.legendBox below dirichletLine \\n   layer D.legendBox below neumannLegend\\n   layer D.legendBox below neumannLine\\n}\\n\\n\\n-- WalkOnStars.style\\n\\n-- WalkOnStars {\\n--    -- Make the image wider to accommodate a legend\\n--    override canvas.width = 333.33\\n-- }\\n-- \\n-- -- Offset the domain so that it's not covered up\\n-- -- too much by the legend\\n-- forall Domain D\\n-- where hasLegend(D)\\n-- {\\n--    override D.offset = (-50,0)\\n-- }\\n-- \\n-- -- Place the starting point\\n-- forall Point `x0` {\\n--    override `x0`.location = (-85,30)\\n-- }\\n\\n-- walk-on-spheres-no-subdomains.style -----------\\n\\n-- -- hide subdomains\\n-- forall Ball B; Point p\\n-- where B := ballAround(p) {\\n--    override B.ball.visibility = \\\"hidden\\\"\\n-- }\\n-- forall Star St; Point p\\n-- where St := starAround(p) {\\n--    override St.ball.visibility = \\\"hidden\\\"\\n-- }\\n-- \\n-- -- hide points sampled from subdomains\\n-- forall Point p; Ball B\\n-- where p := sampleBoundary( B ) {\\n--    override p.dot.visibility = \\\"hidden\\\"\\n-- }\\n-- forall Point p; Star St\\n-- where p := sampleBoundary( St ) {\\n--    override p.dot.visibility = \\\"hidden\\\"\\n-- }\\n-- \\n-- -- make trajectories more transparent\\n-- noSubdomains {\\n--    override Global.walkColor = #1b1f8a30\\n-- }\\n-- \\n-- -- don't worry about domain label avoiding subdomains, since\\n-- -- there will be many hidden subdomains; instead, make sure\\n-- -- the label avoids the walk lines\\n-- forall Subdomain S; Domain D\\n-- where D has label {\\n--    delete S.avoidDomainLabel\\n-- }\\n-- forall Point p; Subdomain S; Domain D\\n-- where p := sampleBoundary( S ) {\\n--    ensure disjoint( D.labelText, p.walkLine, Global.labelPadding ) in labelStage\\n-- }\\n-- forall NestedPoint p; Subdomain S; Domain D\\n-- where p := sampleBoundaryNested( S ) {\\n--    ensure disjoint( D.labelText, p.walkLine, Global.labelPadding ) in labelStage\\n-- }\\n-- forall Point q; Point p; Domain D\\n-- where q := closestBoundaryPoint( D, p ) {\\n--    ensure disjoint( D.labelText, q.walkLine, Global.labelPadding ) in labelStage\\n-- }\\n\\n-- StarShapedRadii.style ------------------------\\n\\n-- -- Widgets to draw the smallest ball touching the Dirichlet boundary,\\n-- -- and the smallest ball toughing the Neumann silhouette.\\n-- forall Star St; Point p; Domain D\\n-- where St := starAround(p) {\\n-- \\n--    vec2 c = p.location\\n--    vec2 yDirichlet = closestPoint( D.dirichletBoundary, c )\\n--    vec2 yNeumann = closestSilhouettePoint( D.neumannBoundary, c )\\n-- \\n--    shape St.dirichletBall = Circle {\\n--       center: c\\n--       r: St.dDirichlet\\n--       fillColor: none()\\n--       strokeColor: #ff6666\\n--       strokeWidth: 1.5 * Global.sphereStrokeWidth\\n--       ensureOnCanvas: false\\n--    }\\n-- \\n--    scalar thetaD = 0\\n--    vec2 x0D = c\\n--    vec2 x1D = c + St.dDirichlet * (cos(thetaD),sin(thetaD))\\n--    vec2 mD = (x0D + x1D)/2\\n--    vec2 nD = rot90(unit(x1D - x0D))\\n--    shape St.dirichletLine = Line {\\n--       start: x0D\\n--       end: x1D\\n--       strokeColor: St.dirichletBall.strokeColor\\n--       strokeWidth: St.dirichletBall.strokeWidth\\n--       fill: \\\"none\\\"\\n--       ensureOnCanvas: false\\n--    }\\n--    shape St.dirichletLabel = Equation {\\n--       center: mD + nD * Global.labelHeight * .75\\n--       string: \\\"d_{\\\\text{Dirichlet}}\\\"\\n--       texContourColor: \\\"white\\\"\\n--       fillColor: St.dirichletBall.strokeColor\\n--       ensureOnCanvas: false\\n--       fontFamily: Global.labelFont\\n--       fontSize: Global.labelSize\\n--       -- rotation: toDegrees(-thetaD)\\n--    }\\n--    shape St.dirichletPoint = Circle {\\n--       center: yDirichlet\\n--       r: Global.dotSize\\n--       fillColor : Colors.white\\n--       strokeColor : St.dirichletBall.strokeColor\\n--       strokeWidth : Global.openDotWidth\\n--       ensureOnCanvas: false\\n--    }\\n--    shape St.closestDirichlet = Group {\\n--       shapes: [ St.dirichletBall, St.dirichletLine, St.dirichletPoint ]\\n--       ensureOnCanvas: false\\n--    }\\n--    layer p.dot above St.closestDirichlet\\n--    layer St.closestDirichlet above St.ball\\n--    layer St.closestDirichlet above D.neumannBoundary\\n--    layer St.dirichletPoint above St.dirichletBall\\n-- \\n--    shape St.neumannBall = Circle {\\n--       center: c\\n--       r: St.dNeumann\\n--       fillColor: none()\\n--       strokeColor: #6666ff\\n--       strokeWidth: 1.5 * Global.sphereStrokeWidth\\n--       ensureOnCanvas: false\\n--    }\\n--    scalar thetaN = MathPI()\\n--    vec2 x0N = c\\n--    vec2 x1N = c + St.dNeumann * (cos(thetaN),sin(thetaN))\\n--    vec2 mN = (x0N + x1N)/2\\n--    vec2 nN = rot90(unit(x1N - x0N))\\n--    shape St.neumannLine = Line {\\n--       start: x0N\\n--       end: x1N\\n--       strokeColor: St.neumannBall.strokeColor\\n--       strokeWidth: St.neumannBall.strokeWidth\\n--       fill: \\\"none\\\"\\n--       ensureOnCanvas: false\\n--    }\\n--    shape St.neumannLabel = Equation {\\n--       center: mN - nN * Global.labelHeight * .75\\n--       string: \\\"d_{\\\\text{silhouette}}\\\"\\n--       texContourColor: \\\"white\\\"\\n--       fillColor: St.neumannBall.strokeColor\\n--       ensureOnCanvas: false\\n--       fontFamily: Global.labelFont\\n--       fontSize: Global.labelSize\\n--       -- rotation: toDegrees(-thetaN)\\n--    }\\n--    shape St.neumannPoint = Circle {\\n--       center: yNeumann\\n--       r: Global.dotSize\\n--       fillColor : Colors.white\\n--       strokeColor : St.neumannBall.strokeColor\\n--       strokeWidth : Global.openDotWidth\\n--       ensureOnCanvas: false\\n--    }\\n--    shape St.closestSilhouette = Group {\\n--       shapes: [ St.neumannBall, St.neumannLine, St.neumannPoint ]\\n--       ensureOnCanvas: false\\n--    }\\n--    layer p.dot above St.closestSilhouette\\n--    layer St.neumannPoint above St.neumannBall\\n--    layer St.closestSilhouette above St.ball\\n--    layer St.closestSilhouette above D.neumannBoundary\\n-- \\n--    layer St.neumannLabel above St.closestSilhouette\\n--    layer St.neumannLabel above St.closestDirichlet\\n--    layer St.dirichletLabel above St.closestSilhouette\\n--    layer St.dirichletLabel above St.closestDirichlet\\n-- }\\n-- \\n-- forall Star St; Point p; Domain D\\n-- where p has label; St := starAround(p) {\\n--    ensure disjoint( p.labelText, St.neumannLabel ) in labelStage\\n--    ensure disjoint( p.labelText, St.dirichletLabel ) in labelStage\\n-- }\\n-- \\n-- forall Star St; Point p; Domain D\\n-- where D has label; St := starAround(p) {\\n--    ensure disjoint( D.labelText, St.neumannBall ) in labelStage\\n--    ensure disjoint( D.labelText, St.dirichletBall ) in labelStage\\n-- }\\n-- \\n-- forall Star St; Point p; Domain D\\n-- where St has label; St := starAround(p) {\\n--    ensure disjoint( St.labelText, St.neumannLabel ) in labelStage\\n--    ensure disjoint( St.labelText, St.dirichletLabel ) in labelStage\\n-- }\\n\\n-- StarShapedRegion.style ------------------------\\n\\n-- -- draw uniformly-spaced rays to the boundary of the star-shaped region\\n-- forall Ray r; Point p; Star St; Domain D\\n-- where r := toBoundary(p,St); St := starAround(p) {\\n-- \\n--    override r.x = St.ball.center\\n--    override r.theta = 2*MathPI() * (match_id - 1)/match_total\\n--    \\n--    scalar dBall  = rayIntersectDistance( St.ball, r.x, r.v )\\n--    scalar dDomain  = rayIntersectDistance( D.neumannBoundary, r.x, r.v )\\n--    scalar R = min( dBall, dDomain )\\n--    override r.L = R\\n-- \\n--    override r.icon.ensureOnCanvas = false\\n-- \\n--    layer r.icon above St.ball\\n--    layer p.dot above r.icon\\n-- }\\n\\n-- alternate-domain.style ------------------------\\n\\n-- forall Domain D {\\n--    vec2 D.q1 = ((.92,.84) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q2 = ((.84,.88) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q3 = ((.55,.60) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q4 = ((.68,.96) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q5 = ((.59,1.0) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q6 = ((.33,.90) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q7 = ((.41,.58) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q8  = ((.16,.77) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q9  = ((0.0,.49) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q10 = ((.03,.15) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q11 = ((.43,0.0) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q12 = ((.32,.32) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q13 = ((.48,.36) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q14 = ((.46,.06) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q15 = ((.76,0.0) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q16 = ((1.0,.27) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q17 = ((.77,.43) - (0.5,0.5)) * D.scale + D.offset\\n-- \\n--    -- domain boundary\\n--    override D.geometry.points = ( D.q1, D.q2, D.q3, D.q4, D.q5, D.q6, D.q7, D.q8, D.q9, D.q10, D.q11, D.q12, D.q13, D.q14, D.q15, D.q16, D.q17 )\\n-- \\n--    -- Dirichlet boundary\\n--    override D.poly0.points = ( D.q8, D.q9, D.q10, D.q11 )\\n-- \\n--    -- Neumann boundary\\n--    override D.poly1.points = ( D.q1, D.q2, D.q3, D.q4, D.q5, D.q6, D.q7, D.q8 )\\n-- \\n--    -- Dirichlet boundary\\n--    override D.poly2.points = ( D.q16, D.q17, D.q1 )\\n-- \\n--    -- Neumann boundary\\n--    override D.poly3.points = ( D.q11, D.q12, D.q13, D.q14, D.q15, D.q16 )\\n-- }\\n-- \\n-- forall Point `x` {\\n--    override `x`.location = (0,0)\\n-- }\\n\\n-- WalkOnSpheresTrajectories.style -----------\\n\\n-- forall Point `x0` {\\n--    override `x0`.location = (0,0)\\n-- }\\n\\n\";\n//# sourceMappingURL=walk-on-spheres.style.js.map","export default \"type Domain -- a region in ℝⁿ\\npredicate hasMixedBoundaryConditions( Domain D )\\npredicate hasLegend( Domain D )\\n\\ntype Point\\npredicate isSourceSample( Point p )\\nconstructor closestBoundaryPoint( Domain D, Point p ) -> Point q\\n\\ntype Subdomain\\ntype Ball <: Subdomain\\ntype Star <: Subdomain\\nconstructor sampleBoundary( Subdomain S ) -> Point p\\nconstructor sampleInterior( Subdomain S ) -> Point p\\n\\nconstructor ballAround( Point p ) -> Ball\\nconstructor starAround( Point p ) -> Star\\npredicate isOffCenter( Ball B ) -- is not centered around p\\n\\ntype NestedPoint\\nconstructor startWalkFrom( Subdomain S ) -> NestedPoint p\\nconstructor nestedBallAround( NestedPoint p ) -> Ball\\nconstructor sampleBoundaryNested( Subdomain S ) -> NestedPoint p\\n\\ntype Ray\\nconstructor toBoundary( Point p, Subdomain S ) -> Ray\\nconstructor headOf( Ray r ) -> Point\\n\\n\";\n//# sourceMappingURL=walk-on-spheres.domain.js.map","import substance from \"./Laplace.substance.js\";\nimport style0, { resolver as resolver0 } from \"./walk-on-spheres.style.js\";\nimport domain from \"./walk-on-spheres.domain.js\";\nexport default {\n    substance,\n    style: [\n        { contents: style0, resolver: resolver0 },\n    ],\n    domain,\n    variation: \"LilyDunlin3394\",\n    excludeWarnings: []\n};\n//# sourceMappingURL=laplace-estimator.trio.js.map","import { PathResolver } from \"@penrose/core\";\nimport { useState } from \"react\";\nimport styled from \"styled-components\";\nimport { Simple } from \"./Simple.js\";\nimport Logo from \"./icons/Logo.js\";\nimport Resample from \"./icons/Resample.js\";\n\nconst Container = styled.div`\n  position: relative;\n  border-radius: 10px;\n  border: 0.5px solid rgba(0, 0, 0, 0.2);\n  box-shadow: 0 5px 8px 0 rgba(0, 0, 0, 0.2);\n  background-color: #fff;\n  overflow: hidden;\n  min-height: 320px;\n`;\n\nconst StartOverlay = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: absolute;\n  background-color: #0001;\n  font-size: 20px;\n  color: #000;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  cursor: pointer;\n`;\n\nconst Stage = styled.div<{ $active?: boolean }>`\n  border-radius: 5px;\n  background-color: ${(props) => (props.$active ? \"#40b4f7\" : \"#bbb\")};\n  padding: 1px 3px;\n  align-self: start;\n  color: white;\n`;\n\nconst StageContainer = styled.div`\n  display: flex;\n  margin-right: auto;\n  font-family: \"Open Sans\", sans-serif;\n  font-size: 14px;\n  width: 100%;\n  flex-wrap: wrap;\n  justify-content: center;\n  margin: 10px 0px;\n`;\n\n// variation from SimpleProps is just the initial variation; the actual\n// variation is stored in state, can be changed by resampling\nexport default (props: {\n  trio: { substance: string; domain: string; style: string; variation: string };\n  imageResolver: PathResolver;\n}) => {\n  const { trio, imageResolver } = props;\n  const { variation, substance, style, domain } = trio;\n  const [currVariation, setVariation] = useState(variation);\n  const [stageIdx, setStageIdx] = useState(0);\n  const [start, setStart] = useState(false);\n  const [stages, setStages] = useState([\"\"]);\n\n  return (\n    <Container>\n      {start ? (\n        <>\n          <Simple\n            name={\"embed\"}\n            domain={domain}\n            substance={substance}\n            style={style}\n            variation={currVariation}\n            interactive={false}\n            animate={true}\n            stepSize={5}\n            imageResolver={imageResolver}\n            onFrame={(s) => {\n              setStages(s.optStages);\n              setStageIdx(s.currentStageIndex);\n            }}\n          />\n          <StageContainer>\n            {stages.map((stage, n) => {\n              const s = stage === \"\" ? \"default\" : stage;\n              return n === stageIdx ? (\n                <Stage $active>{s}</Stage>\n              ) : (\n                <Stage>{s}</Stage>\n              );\n            })}\n            <div\n              onClick={() => setVariation(Math.random().toString())}\n              style={{ cursor: \"pointer\" }}\n            >\n              <Resample size={28} color={\"black\"} />\n            </div>\n          </StageContainer>\n        </>\n      ) : (\n        <div\n          style={{\n            display: \"flex\",\n            alignItems: \"center\",\n            justifyContent: \"center\",\n          }}\n        >\n          <StartOverlay onClick={() => setStart(true)}>\n            Click to lay out the diagram\n          </StartOverlay>\n          <Logo width={350} color={\"#0001\"}></Logo>\n        </div>\n      )}\n    </Container>\n  );\n};\n"],"names":["vector","substance","style0","resolver0","domain","substance$1","resolver","makeResolver","style0$1","style1","domain$1","geometry","resolver1","laplace","Container","styled","StartOverlay","Stage","div","StageContainer","StagedDiagram$1","__name","props","trio","imageResolver","variation","style","currVariation","setVariation","useState","stageIdx","setStageIdx","start","setStart","stages","setStages","_jsx","_jsxs","_Fragment","Simple","stage","n","s","Resample","Logo"],"mappings":"ugBAGA,MAAeA,EAAA,CACf,UAAIC,EACA,MAAO,CACH,CAAE,SAAUC,EAAQ,SAAUC,CAAW,CAC5C,EACL,OAAIC,EACA,UAAW,iBACX,gBAAiB,CAAC,0BAA0B,CAChD,ECXAC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECCFC,EAAWC,EAAa,iBAAiB,EACtDC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCDFF,EAAWC,EAAa,mCAAmC,EACxEE,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCFfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qDCIAC,EAAA,CACf,UAAIV,EACA,MAAO,CACH,CAAE,SAAUC,EAAQ,SAAUC,CAAW,EACzC,CAAE,SAAUM,EAAQ,SAAUG,CAAW,CAC5C,EACL,OAAIR,EACA,UAAW,sBACX,gBAAiB,CAAC,0BAA0B,CAChD,ECbAH,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECCFK,EAAWC,EAAa,iBAAiB,EACtDL,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECFfE,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECGAS,EAAA,CACX,UAAAZ,EACA,MAAO,CACH,CAAE,SAAUC,EAAQ,SAAUC,CAAW,CAC5C,EACD,OAAAC,EACA,UAAW,iBACX,gBAAiB,CAAE,CACvB,ECJAU,EAAAC,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUAC,EAAAD,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeAE,EAAAF,EAAA;AAAA;AAAA,sBAAqBG,GAAAA,EAAAA,QAAAA,UAAAA,MAAAA;AAAAA;AAAAA;AAAAA;AAAAA,EAQrBC,EAAAJ,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaAK,EAAAC,EAAAC,GAAA,CAIE,KAAA,CAAM,KAAAC,EAAEA,cAAAA,CAAMC,EAAAA,EACd,CAAM,UAAAC,EAAEA,UAAAA,EAAWxB,MAAAA,EAAWyB,OAAAA,CAAOtB,EAAAA,EACrC,CAAAuB,EAAAC,CAAA,EAAAC,EAAA,SAAAJ,CAAA,EACA,CAAAK,EAAAC,CAAA,EAAAF,EAAA,SAAA,CAAA,EACA,CAAAG,EAAAC,CAAA,EAAAJ,EAAA,SAAA,EAAA,EACA,CAAAK,EAAAC,CAAA,EAAAN,EAAAA,SAAA,CAAA,EAAA,CAAA,EAEA,OAAAO,EAAAtB,EAAA,CACY,SAAAkB,EAAAK,EAAAC,EAAA,CAEN,SAAA,CAAAF,EAAAG,EAAA,CACS,KAAA,QACC,OAAAnC,EACNA,UAAAA,EACAH,MAAAA,EACAyB,UAAAA,EACWC,YAAAA,GACE,QAAA,GACJ,SAAA,EACC,cAAAH,EACVA,QAAAA,GAAAA,CAEEW,EAAAA,EAAAA,SAAAA,EACAJ,EAAAA,EAAAA,iBAAAA,CAA+B,CACjC,CAAA,EAAAM,EAAAlB,EAAA,CAEa,SAAA,CAAAe,EAAA,IAAA,CAAAM,EAAAC,IAAA,CAEX,MAAAC,EAAAF,IAAA,GAAA,UAAAA,EACA,OAAAC,IAAAX,EAAAM,EAAAnB,EAAA,CACQ,QAAA,GAAQ,SAAAyB,CAAEA,CAAAA,EAAAA,EAAAA,EAAAA,CAEV,SAAAA,CAAEA,CAAAA,CAAS,CAAA,EAAAN,EAAA,MAAA,CAGrB,QAAA,IAAAR,EAAA,KAAA,OAAA,EAAA,SAAA,CAAA,EACsD,MAAA,CAC7C,OAAA,SAAU,EAAU,SAAAQ,EAAAO,EAAA,CAElB,KAAA,GAAO,MAAA,OAAW,CAAA,CAAU,CAAA,CAAA,CACjC,CAAA,CAAA,CACS,CAAA,EAAAN,EAAA,MAAA,CAGnB,MAAA,CACS,QAAA,OACI,WAAA,SACG,eAAA,QACI,EAClB,SAAA,CAAAD,EAAApB,EAAA,CAEa,QAAA,IAAAiB,EAAA,EAAA,EAA6B,SAAA,8BAAG,CAAA,EAAAG,EAAAQ,EAAA,CAGxC,MAAA,IAAQ,MAAA,OAAY,CAAA,CAAA,CAAgB,CAAA,CACtC,CAAA,CAIb,EA/DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}